{"hiddenService":"mh7mkfvezts5j6yu.onion","webDetected":true,"sshDetected":false,"ricochetDetected":false,"ircDetected":false,"ftpDetected":false,"smtpDetected":false,"bitcoinDetected":false,"mongodbDetected":false,"vncDetected":false,"xmppDetected":false,"serverPoweredBy":"","serverVersion":"nginx/1.6.2 (Ubuntu)","foundApacheModStatus":false,"relatedOnionServices":null,"relatedOnionDomains":null,"linkedSites":["www.ponylang.org","tutorial.ponylang.org","en.wikipedia.org","bluishcoder.co.nz","joearms.github.io","github.com","waspvm.blogspot.co.nz","sites.google.com","waspvm.blogspot.com","web.archive.org","www.gnu.org","sourceware.org","www.musl-libc.org","ponylang.org","erights.org","www.erlang.org","patterns.ponylang.org","news.ycombinator.com","www.youtube.com","bitmessage.org","freesocial.draketo.de","keybase.io","blueprintcss.org","git.musl-libc.org","nameid.org","secure","www"],"internalPages":["","mh7mkfvezts5j6yu.onion"],"ipAddresses":null,"openDirectories":null,"exifImages":null,"interestingFiles":null,"pageReferencedDirectories":[".",".","./css","./css","./css","./css","./css",".","././2016/07/18","./2010/11/23","./tags/pony","././2016/07/14","./2009/11/27","./tags/waspvm","././2016/06/05","./2009/11/27","./2009/11/28","./tags/waspvm","././2016/05/11","./2016/03/15","./tags/pony","././2016/05/04","./tags/pony","./page2","mh7mkfvezts5j6yu.onion","./tags/acme","./tags/ajax","./tags/alice","./tags/aliceml","./tags/ats","./tags/audio","./tags/b2g","./tags/backbase","./tags/bitcoin","./tags/bjj","./tags/blackdog","./tags/commonlisp","./tags/concurrency","./tags/continuations","./tags/cyclone","./tags/dojo","./tags/eee","./tags/erlang","./tags/facebook","./tags/factor","./tags/firefox","./tags/flash","./tags/forth","./tags/freenet","./tags/fxos","./tags/git","./tags/gstreamer","./tags/happs","./tags/haskell","./tags/hyperscope","./tags/inferno","./tags/io","./tags/javascript","./tags/links","./tags/martialarts","./tags/minix","./tags/misc","./tags/mobile","./tags/mozartoz","./tags/mozilla","./tags/namecoin","./tags/nanojit","./tags/nixos","./tags/ocaml","./tags/occam","./tags/ogg","./tags/openid","./tags/picolisp","./tags/pitcairn","./tags/poker","./tags/pony","./tags/programming","./tags/pure","./tags/rust","./tags/scala","./tags/scheme","./tags/seaside","./tags/self","./tags/servo","./tags/smalltalk","./tags/tamarin","./tags/theora","./tags/tinyvid","./tags/ukulele","./tags/urweb","./tags/video","./tags/vodka","./tags/vorbis","./tags/waspvm","./tags/webm","./tags/yaws","./tags/zeronet","./tags/zimbra","./2016","./2015","./2014","./2013","./2012","./2011","./2010","./2009","./2008","./2007","./2006","./2005","./articles",".",".","."],"pgpKeys":null,"hashes":["56cddc3956701f0aee707ac81668bca209183d23"],"snapshot":"\n\u003c!DOCTYPE html\u003e\n\u003chtml\u003e\n\u003chead\u003e\n   \u003cmeta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\" /\u003e\n   \u003ctitle\u003eBluish Coder\u003c/title\u003e\n   \u003cmeta name=\"author\" content=\"Chris Double\" /\u003e\n\n   \u003clink href=\"./atom.xml\" rel=\"alternate\" title=\"Bluish Coder\" type=\"application/atom+xml\" /\u003e\n   \u003clink rel=\"alternate\" type=\"application/rss+xml\" title=\"RSS\" href=\"./rss.xml\"/\u003e \n\n   \u003clink rel=\"stylesheet\" href=\"./css/screen.css\" type=\"text/css\" media=\"screen, projection\"\u003e\n   \u003clink rel=\"stylesheet\" href=\"./css/print.css\" type=\"text/css\" media=\"print\"\u003e\n   \u003c!--[if lt IE 8]\u003e\u003clink rel=\"stylesheet\" href=\"./css/ie.css\" type=\"text/css\" media=\"screen, projection\"\u003e\u003c![endif]--\u003e\n   \u003clink rel=\"stylesheet\" href=\"./css/syntax.css\" type=\"text/css\" /\u003e\n   \u003clink rel=\"stylesheet\" href=\"./css/bluishcoder.css\" type=\"text/css\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n  \u003cdiv class=\"container\"\u003e\n    \u003cdiv class=\"span-24 blog-header\"\u003e\n      \u003ch1 id=\"blog-title\"\u003e\u003ca href=\"./index.html\"\u003eBluish Coder\u003c/a\u003e\u003c/h1\u003e\n      \u003cp id=\"blog-description\"\u003eProgramming Languages, Martials Arts and Computers. The Weblog of Chris Double.\u003c/p\u003e\n    \u003c/div\u003e\n    \n    \u003chr\u003e\n    \u003cdiv class=\"span-20\"\u003e\n      \n\n  \n    \u003cdiv class=\"post\"\u003e\n      \u003cdiv class=\"span-2\"\u003e\u003cp class=\"small-heading\"\u003e2016-07-18\u003c/p\u003e\u003c/div\u003e\n      \u003cdiv class=\"span-18 last\"\u003e\n      \u003ch2 class=\"post-title\"\u003e\u003ca href=\"././2016/07/18/borrowing-in-pony.html\"\u003eBorrowing in Pony\u003c/a\u003e\u003c/h2\u003e\n      \u003cp\u003eThe 'TL;DR' of this post on how to borrow internal fields of \u003ccode\u003eiso\u003c/code\u003e objects in Pony is:\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003eTo borrow fields internal to an \u003ccode\u003eiso\u003c/code\u003e object, \u003ccode\u003erecover\u003c/code\u003e the object to a \u003ccode\u003eref\u003c/code\u003e (or other valid capability) perform the operations using the field, then consume the object back to an \u003ccode\u003eiso\u003c/code\u003e.\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003eRead on to find out why.\u003c/p\u003e\n\n\u003cp\u003eIn this post I use the term borrowing to describe the process of taking a pointer or reference internal to some object, using it, then returning it. An example from C would be something like:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003evoid* new_foo();\nvoid* get_bar(foo* f);\nvoid  delete_foo(foo* f);\n\n...\nvoid* f = new_foo();\nvoid* b = get_bar(f);\n...\ndelete_foo(f);\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eHere a new \u003ccode\u003efoo\u003c/code\u003e is created and a pointer to a \u003ccode\u003ebar\u003c/code\u003e object returned from it. This pointer is to data internal to \u003ccode\u003efoo\u003c/code\u003e. It's important not to use it after \u003ccode\u003efoo\u003c/code\u003e is deleted as it will be a dangling pointer. While holding the \u003ccode\u003ebar\u003c/code\u003e pointer you have an alias to something internal to \u003ccode\u003efoo\u003c/code\u003e. This makes it difficult to share \u003ccode\u003efoo\u003c/code\u003e with other threads or reason about data races. The \u003ccode\u003efoo\u003c/code\u003e object could change the \u003ccode\u003ebar\u003c/code\u003e data without the holder of the borrowed pointer to \u003ccode\u003ebar\u003c/code\u003e knowing making it a dangling pointer, or invalid data, at any time. I go through a real world case of this in my article on \u003ca href=\"./2010/11/23/more-on-type-safety-using-c-and-ats.html\"\u003eusing C in the ATS programming language\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://www.ponylang.org/\"\u003ePony\u003c/a\u003e has the concept of a reference to an object where only one pointer to that object exists. It can't be aliased and nothing else can read or write to that object but the current reference to it. This is the \u003ccode\u003eiso\u003c/code\u003e reference capability. Capabilities are 'deep' in pony, rather than 'shallow'. This means that the reference capability of an alias to an object affects the reference capabilities of fields of that object as seen by that alias. The description of this is in the \u003ca href=\"http://tutorial.ponylang.org/capabilities/combining-capabilities.html\"\u003eviewpoint adaption\u003c/a\u003e section of the Pony tutorial.\u003c/p\u003e\n\n\u003cp\u003eThe following is a Pony equivalent of the previous C example:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eclass Foo\n  let bar: Bar ref\n...\nlet f: Foo ref = Foo.create()\nlet b: Bar ref = f.bar\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe reference capability of \u003ccode\u003ef\u003c/code\u003e determines the reference capability of \u003ccode\u003ebar\u003c/code\u003e as seen by \u003ccode\u003ef\u003c/code\u003e. In this case \u003ccode\u003ef\u003c/code\u003e is a \u003ccode\u003eref\u003c/code\u003e (the default of class objects) which according to the \u003ca href=\"http://tutorial.ponylang.org/capabilities/combining-capabilities.html\"\u003eviewpoint adaption table\u003c/a\u003e means that \u003ccode\u003ebar\u003c/code\u003e as seen by \u003ccode\u003ef\u003c/code\u003e  is also a \u003ccode\u003eref\u003c/code\u003e. Intuitively this makes sense - a \u003ccode\u003eref\u003c/code\u003e signifies multiple read/write aliases can exist therefore getting a read/write alias to something internal to the object is no issue. A \u003ccode\u003eref\u003c/code\u003e is not sendable so cannot be accessed from multiple threads.\u003c/p\u003e\n\n\u003cp\u003eIf \u003ccode\u003ef\u003c/code\u003e is an \u003ccode\u003eiso\u003c/code\u003e then things change:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eclass Foo\n  let bar: Bar ref\n...\nlet f: Foo iso = recover iso Foo.create() end\nlet b: Bar tag = f.bar\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eNow \u003ccode\u003ebar\u003c/code\u003e as seen by \u003ccode\u003ef\u003c/code\u003e is a \u003ccode\u003etag\u003c/code\u003e. A \u003ccode\u003etag\u003c/code\u003e can be aliased but cannot be used to read/write to it. Only object identity and calling behaviours is allowed. Again this is intuitive. If we have a non-aliasable reference to an object (\u003ccode\u003ef\u003c/code\u003e being \u003ccode\u003eiso\u003c/code\u003e here) then we can't alias internally to the object either. Doing so would mean that the object could be changed on one thread and the internals modified on another giving a data race.\u003c/p\u003e\n\n\u003cp\u003eThe viewpoint adaption table shows that given an iso \u003ccode\u003ef\u003c/code\u003e it's very difficult to get a \u003ccode\u003ebar\u003c/code\u003e that you can write to. The following read only access to \u003ccode\u003ebar\u003c/code\u003e is ok:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eclass Foo\n  let bar: Bar val\n...\nlet f: Foo iso = recover iso Foo.create() end\nlet b: Bar val = f.bar\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eHere \u003ccode\u003ebar\u003c/code\u003e is a val. This allows multiple aliases, sendable across threads, but only read access is provided. Nothing can write to it. According to viewpoint adaption, \u003ccode\u003ebar\u003c/code\u003e as seen by \u003ccode\u003ef\u003c/code\u003e is a \u003ccode\u003eval\u003c/code\u003e. It makes sense that given a non-aliasable reference to an object, anything within that object that is immutable is safe to borrow since it cannot be changed. What if \u003ccode\u003ebar\u003c/code\u003e is itself an \u003ccode\u003eiso\u003c/code\u003e?\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eclass Foo\n  let bar: Bar iso = recover iso Bar end\n...\nlet f: Foo iso = recover iso Foo.create() end\nlet b: Bar iso = f.bar\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThis won't compile. Viewpoint adaption shows that \u003ccode\u003ebar\u003c/code\u003e as seen by \u003ccode\u003ef\u003c/code\u003e is an \u003ccode\u003eiso\u003c/code\u003e. The assignment to \u003ccode\u003eb\u003c/code\u003e doesn't typecheck because it's aliasing an \u003ccode\u003eiso\u003c/code\u003e and \u003ccode\u003eiso\u003c/code\u003e reference capabilities don't allow aliasing. The usual solution when a field isn't involved is to \u003ccode\u003econsume\u003c/code\u003e the original but it won't work here. The contents of an objects field can't be consumed because it would then be left in an undefined state. A \u003ccode\u003eFoo\u003c/code\u003e object that doesn't have a valid \u003ccode\u003ebar\u003c/code\u003e is not really a \u003ccode\u003eFoo\u003c/code\u003e. To get access to \u003ccode\u003ebar\u003c/code\u003e externally from \u003ccode\u003eFoo\u003c/code\u003e the \u003ca href=\"http://tutorial.ponylang.org/capabilities/consume-and-destructive-read.html\"\u003edestructive read\u003c/a\u003e syntax is required:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eclass Foo\n  var bar: Bar iso = recover iso Bar end\n...\nlet f: Foo iso = recover iso Foo.create() end\nlet b: Bar iso = f.bar = recover iso Bar end\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThis results in \u003ccode\u003ef.bar\u003c/code\u003e being set to a new instance of \u003ccode\u003eBar\u003c/code\u003e so it's never in an undefined state. The old value of \u003ccode\u003ef.bar\u003c/code\u003e is then assigned to \u003ccode\u003eb\u003c/code\u003e. This is safe as there are no aliases to it anymore due to the first part of the assignment being done first.\u003c/p\u003e\n\n\u003cp\u003eWhat if the internal field is a \u003ccode\u003eref\u003c/code\u003e and we really want to access it as a \u003ccode\u003eref\u003c/code\u003e? This is possible using \u003ca href=\"http://tutorial.ponylang.org/capabilities/recovering-capabilities.html\"\u003erecover\u003c/a\u003e. As described in the tutorial, one of the uses for recover is:\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e\"Extract\" a mutable field from an iso and return it as an iso.\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003eThis looks like:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eclass Foo\n  let bar: Bar ref\n... \nlet f: Foo iso = recover iso Foo end\nlet f' = recover iso\n           let f'': Foo ref = consume f\n           let b: Bar ref = f''.bar\n           consume f''\n         end\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eInside the \u003ccode\u003erecover\u003c/code\u003e block \u003ccode\u003ef\u003c/code\u003e is consumed and returned as a \u003ccode\u003eref\u003c/code\u003e. The \u003ccode\u003ef\u003c/code\u003e alias to the object no longer exists at this point and we have the same object but as a \u003ccode\u003eref\u003c/code\u003e capability in \u003ccode\u003ef''\u003c/code\u003e. \u003ccode\u003ebar\u003c/code\u003e as seen by \u003ccode\u003ef''\u003c/code\u003e is a \u003ccode\u003eref\u003c/code\u003e according to viewpoint adaption and can now be used within the recover block as a \u003ccode\u003eref\u003c/code\u003e. When the recover block ends the \u003ccode\u003ef''\u003c/code\u003e alias is consumed and returned out of the block as an \u003ccode\u003eiso\u003c/code\u003e again in \u003ccode\u003ef'\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThis works because inside the recover block only sendable values from the enclosing scope can be accessed (ie. \u003ccode\u003eval\u003c/code\u003e, \u003ccode\u003eiso\u003c/code\u003e, or \u003ccode\u003etag\u003c/code\u003e). When exiting the block all aliases except for the object being returned are destroyed. There can be many aliases to \u003ccode\u003ebar\u003c/code\u003e within the block but none of them can leak out. Multiple aliases to \u003ccode\u003ef'\u003c/code\u003e can be created also and they are not going to leaked either. At the end of the block only one can be returned and by consuming it the compiler knows that there are no more aliases to it so it is safe to make it an \u003ccode\u003eiso\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eTo show how the \u003ccode\u003eref\u003c/code\u003e aliases created within the recover block can't escape, here's an example of an erroneous attempt to assign the \u003ccode\u003ef'\u003c/code\u003e alias to an object in the outer scope:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eclass Baz\n  var a: (Foo ref | None) = None\n  var b: (Foo ref | None) = None\n\n  fun ref set(x: Foo ref) =\u0026gt;\n    a = x\n    b = x\n\nclass Bar\n\nclass Foo\n  let bar: Bar ref = Bar\n\nvar baz: Baz iso = recover iso Baz end\nvar f: Foo iso = recover iso Foo end\nf = recover iso\n      let f': Foo ref = consume f\n      baz.set(f')\n      let b: Bar ref = f'.bar\n      consume f'\n    end\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eIf this were to compile then \u003ccode\u003ebaz\u003c/code\u003e would contain two references to the \u003ccode\u003ef'\u003c/code\u003e object which is then consumed as an \u003ccode\u003eiso\u003c/code\u003e. \u003ccode\u003ef\u003c/code\u003e would contain what it thinks is non-aliasable reference but \u003ccode\u003ebaz\u003c/code\u003e would actually hold two additional references to it. This fails to compile at this line:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003emain.pony:20:18: receiver type is not a subtype of target type\n          baz.set(f')\n                 ^\nInfo:\nmain.pony:20:11: receiver type: Baz iso!\n              baz.set(f')\n              ^\nmain.pony:5:3: target type: Baz ref\n      fun ref set(x: Foo ref) =\u0026gt;\n      ^\nmain.pony:20:18: this would be possible if the arguments and return value were all sendable\n              baz.set(f')\n                     ^\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003ebaz\u003c/code\u003e is an \u003ccode\u003eiso\u003c/code\u003e so is allowed to be accessed from within the recover block. But the \u003ccode\u003eset\u003c/code\u003e method on it expects a \u003ccode\u003eref\u003c/code\u003e receiver. This doesn't work because the receiver of a method of an object is also an implicit argument to that method and therefore needs to be aliased. In this way it's not possible to store data created within the recover block in something passed into the recover block externally. No aliases can be leaked and the compiler can track things easily.\u003c/p\u003e\n\n\u003cp\u003eThere is something called \u003ca href=\"http://tutorial.ponylang.org/capabilities/recovering-capabilities.html\"\u003eautomatic receiver recovery\u003c/a\u003e that is alluded to in the error message (\"this would be possible...\") which states that if the arguments were sendable then it is possible for the compiler to work out that it's ok to call a \u003ccode\u003eref\u003c/code\u003e method on an \u003ccode\u003eiso\u003c/code\u003e object. Our \u003ccode\u003eref\u003c/code\u003e arguments are not sendable which is why this doesn't kick in.\u003c/p\u003e\n\n\u003cp\u003eA real world example of where all this comes up is using the Pony \u003ccode\u003enet/http\u003c/code\u003e package. A user on IRC posted the following code snippet:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003euse \"net/http\"\nclass MyRequestHandler is RequestHandler\n\n  let env: Env\n\n  new val create(env': Env) =\u0026gt;\n    env = env'\n\n  fun val apply(request: Payload iso): Any =\u0026gt;\n    for (k, v) in request.headers().pairs() do\n      env.out.print(k)\n      env.out.print(v)\n    end\n\n    let r = Payload.response(200)\n    r.add_chunk(\"Woot\")\n    (consume request).respond(consume r)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe code attempts to iterate over the HTTP request headers and print them out. It fails in the \u003ccode\u003erequest.headers().pairs()\u003c/code\u003e call, complaining that \u003ccode\u003etag is not a subtype of box\u003c/code\u003e in the result of \u003ccode\u003eheaders()\u003c/code\u003e when calling \u003ccode\u003epairs()\u003c/code\u003e. Looking at the \u003ccode\u003ePayload\u003c/code\u003e class definition shows:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eclass iso Payload\n  let _headers: Map[String, String] = _headers.create()\n\n  fun headers(): this-\u0026gt;Map[String, String] =\u0026gt;\n    _headers\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eIn the example code \u003ccode\u003erequest\u003c/code\u003e is an \u003ccode\u003eiso\u003c/code\u003e and the \u003ccode\u003eheaders\u003c/code\u003e function is a \u003ccode\u003ebox\u003c/code\u003e (the default for \u003ccode\u003efun\u003c/code\u003e). The return value of \u003ccode\u003eheaders\u003c/code\u003e uses \u003ca href=\"http://tutorial.ponylang.org/capabilities/arrow-types.html\"\u003ean arrow type\u003c/a\u003e. It reads as \"return a \u003ccode\u003eMap[String, String]\u003c/code\u003e with the reference capability of \u003ccode\u003e_headers\u003c/code\u003e as seen by \u003ccode\u003ethis\u003c/code\u003e\". In this example \u003ccode\u003ethis\u003c/code\u003e is the \u003ccode\u003erequest\u003c/code\u003e object which is \u003ccode\u003eiso\u003c/code\u003e. \u003ccode\u003e_headers\u003c/code\u003e is a \u003ccode\u003eref\u003c/code\u003e according to the class definition. So it's returning a \u003ccode\u003eref\u003c/code\u003e as seen by an \u003ccode\u003eiso\u003c/code\u003e which according to viewpoint adaption is a \u003ccode\u003etag\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThis makes sense as we're getting a reference to the internal field of an \u003ccode\u003eiso\u003c/code\u003e object. As explained previously this must be a \u003ccode\u003etag\u003c/code\u003e to prevent data races. This means that \u003ccode\u003epairs()\u003c/code\u003e can't be called on the result as \u003ccode\u003etag\u003c/code\u003e doesn't allow function calls. \u003ccode\u003epairs()\u003c/code\u003e is a \u003ccode\u003ebox\u003c/code\u003e method which is why the error message refers to \u003ccode\u003etag\u003c/code\u003e not being a subtype of \u003ccode\u003ebox\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eTo borrow the \u003ccode\u003eheaders\u003c/code\u003e correctly we can use the approach done earlier of using a recover block:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003efun val apply(request: Payload iso): Any =\u0026gt;\n  let request'' = recover iso\n    let request': Payload ref = consume request\n    for (k, v) in request'.headers().pairs() do\n      env.out.print(k)\n      env.out.print(v)\n    end\n    consume request'\n  end\n  let r = Payload.response(200)\n  r.add_chunk(\"Woot\")\n  (consume request'').respond(consume r)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eIn short, to borrow fields internal to an \u003ccode\u003eiso\u003c/code\u003e object, \u003ccode\u003erecover\u003c/code\u003e the object to a \u003ccode\u003eref\u003c/code\u003e (or other valid capability) perform the operations using the field, then consume the object back to an \u003ccode\u003eiso\u003c/code\u003e.\u003c/p\u003e\n\n      \u003cdiv\u003eTags: \n        \n          \u003ca href=\"./tags/pony/index.html\"\u003epony\u003c/a\u003e\u0026nbsp;\n        \n      \u003c/div\u003e\n      \u003c/div\u003e\n      \u003chr\u003e\n    \u003c/div\u003e\n  \n    \u003cdiv class=\"post\"\u003e\n      \u003cdiv class=\"span-2\"\u003e\u003cp class=\"small-heading\"\u003e2016-07-14\u003c/p\u003e\u003c/div\u003e\n      \u003cdiv class=\"span-18 last\"\u003e\n      \u003ch2 class=\"post-title\"\u003e\u003ca href=\"././2016/07/14/concurrency-in-wasp-lisp.html\"\u003eConcurrency in Wasp Lisp\u003c/a\u003e\u003c/h2\u003e\n      \u003cp\u003e\u003ca href=\"./2009/11/27/wasp-lisp-small-scheme-like-lisp.html\"\u003eWasp Lisp\u003c/a\u003e has a light weight co-operative threading model that's allows programming in an \u003ca href=\"https://en.wikipedia.org/wiki/Actor_model\"\u003eActor\u003c/a\u003e style. It's possible to serialize Wasp values and send them to other processes and machines to be deserialized and run. \u003ca href=\"https://bluishcoder.co.nz/2009/11/28/using-wasp-lisp-secure-remote-injection.html\"\u003eMOSREF\u003c/a\u003e uses this to compile Lisp code on the console process and send the bytecode to drone processes to execute. This allows drones to operate without the Lisp compiler present.\u003c/p\u003e\n\n\u003ch2\u003eSpawning threads\u003c/h2\u003e\n\n\u003cp\u003eThreads are created using the \u003ccode\u003espawn\u003c/code\u003e function. It takes the function to run as a thread as an argument:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e(spawn (lambda () (print \"Hello World\\n\")))\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eCommunication between threads is done using queues. A queue is an unbounded channel that can have many senders but only one receiver. The function \u003ccode\u003esend\u003c/code\u003e adds data to the queue and \u003ccode\u003ewait\u003c/code\u003e receives data. If there is no data in the queue then \u003ccode\u003ewait\u003c/code\u003e blocks. Input/Output in Wasp Lisp is done using the same wait/send mechanism making it easy to pipeline data from console and file output to sockets.\u003c/p\u003e\n\n\u003ch2\u003eImplementing Actors\u003c/h2\u003e\n\n\u003cp\u003eA basic Actor can be implemented like the following:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e(define (actor1)\n  (define counter 0)\n  (define chan (make-queue))\n\n  (define (loop)\n    (define msg (wait chan))\n    (cond\n      ((eq? msg 'inc)\n        (set! counter (+ 1 counter)))\n      ((eq? msg 'dec)\n        (set! counter (- 1 counter)))\n      ((and (list? msg) (eq? (car msg) 'get))\n       (send counter (cadr msg))))\n    (loop))\n\n  (spawn loop)\n  chan)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003eactor1\u003c/code\u003e is a function that contains a \u003ccode\u003ecounter\u003c/code\u003e holding an numeric value. It creates \u003ccode\u003echan\u003c/code\u003e, a queue for holding messages, spawns a thread to run \u003ccode\u003eloop\u003c/code\u003e and returns the \u003ccode\u003echan\u003c/code\u003e so messages can be queued for \u003ccode\u003eloop\u003c/code\u003e to process.\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eloop\u003c/code\u003e waits for a message on \u003ccode\u003echan\u003c/code\u003e. This is a blocking call and the thread will go idle until a message is queued. It processes the message, incrementing or decrementing the counter as requested. An additional message, \u003ccode\u003eget\u003c/code\u003e, can be used to get the value of the counter. That message also includes a channel object to place the result in. \u003ccode\u003eloop\u003c/code\u003e recursively calls itself to continue.\u003c/p\u003e\n\n\u003cp\u003eA sample interaction is:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e\u0026gt;\u0026gt; (define a1 (actor1))\n\u0026gt;\u0026gt; (define result (make-queue))\n\u0026gt;\u0026gt; (send (list 'get result) a1)\n\u0026gt;\u0026gt; (wait result)\n:: 0\n\u0026gt;\u0026gt; (send 'inc a1)\n\u0026gt;\u0026gt; (send (list 'get result) a1)\n\u0026gt;\u0026gt; (wait result)\n:: 1\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThis creates an actor and a queue to receive results. It asks for the current value of the actor, increments it, then asks again.\u003c/p\u003e\n\n\u003ch2\u003eUpdating an Actor\u003c/h2\u003e\n\n\u003cp\u003eIt's possible to update the code for an Actor without stopping the application. Running in a \u003ca href=\"https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop\"\u003eLisp REPL\u003c/a\u003e means you can change functions on the fly but you can't change the internal implementation of a running loop from the REPL if that loop is internal to a function. A way around this is to provide the Actor with the means to receive a function as a message that performs the update. Here is an example of an updatable actor:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e(define (actor3)\n  (define counter 0)\n  (define chan (make-queue))\n\n  (define (loop chan)\n    (define msg (wait chan))\n    (cond\n      ((eq? msg 'inc)\n        (set! counter (+ 1 counter)))\n      ((eq? msg 'dec)\n        (set! counter (- 1 counter)))\n      ((and (list? msg) (eq? (car msg) 'get))\n       (send counter (cadr msg)))\n      ((function? msg)\n       (return ((msg counter) chan))))\n    (loop chan))\n\n  (spawn loop chan)\n  chan)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThis code contains an additional branch in the \u003ccode\u003econd\u003c/code\u003e to check if the message is a function. If it is then that function is called passing the current value of the counter. It is expected to return a function which will be the new \u003ccode\u003eloop\u003c/code\u003e to call. This can contain any code and effectively updates the entire actor with new functionality. An example update function to change the messages to increment/decrement by two is:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e(define (update oldstate)\n  (define counter (* oldstate 2))\n  (define (loop chan)\n    (define msg (wait chan))\n    (cond\n      ((eq? msg 'inc)\n        (set! counter (+ 2 counter)))\n      ((eq? msg 'dec)\n        (set! counter (- 2 counter)))\n      ((and (list? msg) (eq? (car msg) 'get))\n       (send counter (cadr msg)))\n      ((function? msg)\n       (return ((msg counter) chan))))\n   (loop chan))\n  loop)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eAn example interaction of the actor and upgrading it is:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e\u0026gt;\u0026gt; (define a3 (actor3))\n\u0026gt;\u0026gt; (define result (make-queue))\n\u0026gt;\u0026gt; (send 'inc a3)\n\u0026gt;\u0026gt; (send (list 'get result) a3)\n\u0026gt;\u0026gt; (wait result)\n:: 1\n\u0026gt;\u0026gt; (send update a3)   ;; Updating the actor here\n\u0026gt;\u0026gt; (send (list 'get result) a3)\n\u0026gt;\u0026gt; (wait result)\n:: 2                  ;; This shows the new counter value that 'update' changed\n\u0026gt;\u0026gt; (send 'inc a3)\n\u0026gt;\u0026gt; (send (list 'get result) a3)\n\u0026gt;\u0026gt; (wait result)\n:: 4                  ;; Amount is now incrementing by two\n\u0026gt;\u0026gt; (send 'inc a3)\n\u0026gt;\u0026gt; (send (list 'get result) a3)\n\u0026gt;\u0026gt; (wait result)\n:: 6\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThis is a variant of \u003ca href=\"https://joearms.github.io/2013/11/21/My-favorite-erlang-program.html\"\u003eJoe Armstrong's Erlang Universal Server\u003c/a\u003e allowing a server to be updated to do anything.\u003c/p\u003e\n\n\u003ch2\u003eFilters\u003c/h2\u003e\n\n\u003cp\u003eAn idiom when programming in an Actor or coroutine style is to write small processes that take an input, modify it in some way, and send it to another process to do something else. A program becomes a chain or pipeline of these individual processes. Wasp Lisp calls these small units of functionality filters. They are described in \u003ca href=\"https://github.com/swdunlop/WaspVM/blob/master/mod/lib/filter.ms\"\u003efilter.ms\u003c/a\u003e as:\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003eA process that waits for data from an input channel, and sends data to an output channel.  Filters are constructed using a constructor function, then wired together using either the input-chain or output-chain functions.\"\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003eThis is an example of a line filter from the Wasp source code;\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e(define-filter (line-filter)\n  (define buf (make-string 80)) \n\n  (define (parse)\n    (forever\n      (define next (string-read-line! buf))\n      (if next (send next out)\n               (return))))\n\n  (define (line-loop)\n    (forever\n      (define next (wait-input in))\n      (cond \n        ((string? next)\n         (string-append! buf next)\n         (parse))\n        ((eq? next 'close)\n         (return))\n        (else\n          (send-output next out)))))\n\n  (line-loop)\n\n  (send-output buf out)\n  (send-output 'close out))\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eA \u003ccode\u003eline-filter\u003c/code\u003e receives strings of bytes on the input channel and outputs a complete line on the output channel when it has one. It does this by appending received bytes onto a string buffer and checking if that buffer contains a line. If it does it removes the line data from the buffer and sends it to the output channel. It then continues to wait for data on the input channel. An example of usage:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e\u0026gt;\u0026gt; (import \"lib/filter\")\n\u0026gt;\u0026gt; (import \"lib/line-filter\")\n\u0026gt;\u0026gt; (define q (make-queue))\n\u0026gt;\u0026gt; (define lines (input-chain q (line-filter)))\n\u0026gt;\u0026gt; (spawn (lambda () (forever (print (wait lines)))))\n\n\u0026gt;\u0026gt; (send \"hello\" q)\n\u0026gt;\u0026gt; (send \"world\\n\" q)\nhelloworld\n\u0026gt;\u0026gt; (send \"foo\\nbar\" q)\nfoo\n\u0026gt;\u0026gt; (send \"baz\\n\" q)\nbarbaz\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThis creates a queue, \u003ccode\u003eq\u003c/code\u003e for input data. It creates a chain containing only one filter, the \u003ccode\u003eline-filter\u003c/code\u003e. It returns the output channel which contains the filtered data. Data placed in \u003ccode\u003eq\u003c/code\u003e is retrieved by the line filter and when a line is received it is sent to the output channel. A thread is spawned to loop forever printing any lines from the output channel.  Notice in the manual sending of data to the channel \u003ccode\u003eq\u003c/code\u003e that output is only printed by the spawned thread when a line is completed.\u003c/p\u003e\n\n\u003cp\u003eWasp Lisp comes with some default filters for parsing s-expressions, encrypting and decrypting data and fuzzing data amongst other things. Scott Dunlop \u003ca href=\"https://waspvm.blogspot.co.nz/2008/08/best-state-machine-is-coroutine.html\"\u003ewrote about coroutines and filters\u003c/a\u003e on the Wasp blog.\u003c/p\u003e\n\n\u003ch2\u003eSending data to other OS processes\u003c/h2\u003e\n\n\u003cp\u003eSome Wasp values can be serialized and deserialized. This provides a way to send values to other wasp instances running in different OS processes or machines. Lisp objects are serialized using \u003ccode\u003efreeze\u003c/code\u003e and unserialized using \u003ccode\u003ethaw\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThe following \u003ccode\u003eserver\u003c/code\u003e function starts a TCP server on port 10000. Clients connnected to it send Lisp objects to it and it prints it to the standard output on the server process.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e(import \"lib/tcp-server\")\n\n(define (server)\n  (define server-output (current-output))\n\n  (define (acceptor)\n    (forever\n      (define data (wait))\n      (with-output server-output\n        (print (format (thaw data)))\n        (print \"\\n\"))))\n\n  (spawn-tcp-server 10000 acceptor))\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe \u003ccode\u003eacceptor\u003c/code\u003e function is called with its current input and output bound to the TCP stream. For this reason we capture the value of \u003ccode\u003ecurrent-output\u003c/code\u003e before it is bound so we can output to the server console rather than to the TCP stream. A sample test:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e;; On server \n\u0026gt;\u0026gt; (server)\n\n;; On client\n\u0026gt;\u0026gt; (define s (tcp-connect \"127.0.0.1\" 10000))\n\u0026gt;\u0026gt; (send (freeze \"foo\") s)\n\n;; On Server\n\"foo\"\n\n;; On Client\n\u0026gt;\u0026gt; (send (freeze 66) s)\n\n;; On Server\n66\n\n;; On Client\n\u0026gt;\u0026gt; (send (freeze '(one (two three))) s)\n\n;; On Server\n(one (two three))\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eNotice that all i/o is done using the 'send' and 'wait' channel operators. This means we can use a filter to do the freezing/thawing automatically and Wasp has a \u003ccode\u003efreeze-filter\u003c/code\u003e and \u003ccode\u003ethaw-filter\u003c/code\u003e that does this. The server becomes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e(import \"lib/tcp-server\")\n(import \"lib/package-filter\")\n(import \"lib/filter\")\n(import \"lib/format-filter\")\n\n(define (server2)             \n  (define server-output (current-output))\n\n  (define (acceptor)\n    (define chan (input-chain (current-input)\n                              (thaw-filter)\n                              (format-filter)))\n    (forever\n      (define data (wait chan))\n      (print* data \"\\n\")))\n\n  (spawn-tcp-server 10000 acceptor))\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eUsage from a client is:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e\u0026gt;\u0026gt; (import \"lib/filter\")\n\u0026gt;\u0026gt; (import \"lib/package-filter\")\n\n\u0026gt;\u0026gt; (define s (tcp-connect \"127.0.0.1\" 10000))\n\u0026gt;\u0026gt; (define chan (output-chain s (freeze-filter)))\n\u0026gt;\u0026gt; (send \"hello\" chan)\n\u0026gt;\u0026gt; (send '(one (two three)) chan)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThrough the use of the thaw/freeze filter there is no need to manually call \u003ccode\u003efreeze\u003c/code\u003e and \u003ccode\u003ethaw\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch2\u003eSending bytecode to other processes\u003c/h2\u003e\n\n\u003cp\u003eUnfortunately it's not possible to freeze or thaw closures or functions. It is possible however to assemble Lisp to bytecode and send that. This enables sending new functions across OS processes and is how MOSREF is able to compile Lisp on the console and send it to the drone. This example will compile a function from source to bytecode and run it:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e\u0026gt;\u0026gt; (define code '((print \"Hello World\\n\")))\n\u0026gt;\u0026gt; (define proc (assemble (optimize (compile code))))\n\u0026gt;\u0026gt; (proc)\nHello World\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe result of \u003ccode\u003eassemble\u003c/code\u003e can be frozen, sent somewhere and thawed:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e\u0026gt;\u0026gt; (define x (freeze (assemble (optimize (compile '((print \"Hello World\\n\")))))))\n\u0026gt;\u0026gt; (define y (thaw x))\n\u0026gt;\u0026gt; (y)\nHello World\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eUsing this we can have an upgradable server process:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e(define (server3)\n  (define server-output (current-output))\n\n  (define (acceptor)\n    (define chan (input-chain (current-input)\n                              (thaw-filter)))\n\n    (define (loop chan)\n      (define data (wait chan))\n      (cond\n        ((function? data)\n          (return ((data) chan)))\n        (else\n          (print* \"OLD: \" (format data) \"\\n\")\n          (return (loop chan)))))\n     (loop chan))\n\n  (spawn-tcp-server 10000 acceptor))\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThis will display the data sent to the server prefixed by \"OLD:\" unless it is sent a function. In which case it calls that function as the new server loop. An upgraded server loop to prefix with \"NEW: \" is:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e(define (new-server3)\n  (assemble\n    (optimize\n      (compile\n        '((define (loop chan)\n            (define data (wait chan))\n            (cond\n              ((function? data)\n                (return ((data) chan)))\n              (else\n                (print* \"NEW: \" (format data) \"\\n\")\n                (return (loop chan))))))))))\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eWe can't send a function directly so this compiles the new loop from source and returns the compiled procedure. This can be frozen, sent to the server and it will execute it as the new loop. An example interaction:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e;; On Server\n\u0026gt;\u0026gt; (server3)\n\n;; On Client\n\u0026gt;\u0026gt; (define s (tcp-connect \"127.0.0.1\" 10000))\n\u0026gt;\u0026gt; (define chan (output-chain s (freeze-filter)))\n\u0026gt;\u0026gt; (send '(one (two three)) chan)\n\n;; On Server\nOLD: (one (two three))\n\n;; On Client\n\u0026gt;\u0026gt; (send (new-server3) chan)\n\u0026gt;\u0026gt; (send '(one (two three)) chan)\n\n;; On Server\n\u0026gt;\u0026gt; NEW: (one (two three))\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eWhy not send the source to the server process and have it \u003ccode\u003eeval\u003c/code\u003e it? The approach of sending the bytecode allows the server process to skip including the Lisp compiler. The Wasp VM includes an interpreter and deserializer - the compiler and other libraries are all in Lisp. A Wasp executable consists of the VM stub with bytecode appended to the end of it. On execution it looks for the bytecode, deserializes it and runs it. This provides a minimal program that can have functionality added by sending it bytecode as needed.\u003c/p\u003e\n\n\u003ch2\u003eAn aside on tail call optimization\u003c/h2\u003e\n\n\u003cp\u003eIt's important that a process loop is tail recursive otherwise each call through the loop will increase stack size and eventually exhaust memory. The following is not tail recursive in Wasp Lisp, even though it looks like it should be:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e(define (test1 chan)\n  (define msg (wait chan))\n  (cond\n    ((eq msg 'foo)\n      (test1 chan))\n    ((eq msg 'bar)\n      (test1 chan))\n    (else\n      (test1 chan))))\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThis is because the recursive call to 'test1' compiles down to bytecode that looks like:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e(newf)\n(ldg eq)\n(arg)\n(ldg msg)\n(arg)\n(ldc bar)\n(arg)\n(call)\n(jf false-47) ;; If the msg is not 'bar then jump to false-47\n...\nfalse-47\n(newf)\n(ldg test1)\n(arg)\n(ldg chan)\n(arg)\n(call)        ;; recursively call 'test1'\ndone-46\ndone-44\n(retn)        ;; return from function 'test1'\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe stack frame for \u003ccode\u003etest1\u003c/code\u003e is not exited (the \u003ccode\u003eretn\u003c/code\u003e instruction) until after the recursive call is done. Compare this to the obvious tail recursive case:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e(newf)\n(ldg wait)\n(arg)\n(ldg chan)\n(arg)\n(call)\n(stg msg)\n(newf)\n(ldg test2)\n(arg)\n(ldg chan)\n(arg)\n(tail)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eNote that \u003ccode\u003etail\u003c/code\u003e instruction. This does an immediate jump rather than a \u003ccode\u003ecall\u003c/code\u003e so a \u003ccode\u003eretn\u003c/code\u003e is not necessary. The call stack does not grow. The difference between the two cases is due to the way the Wasp Lisp compiler generates the instructions and optimizes looking for tail calls. The instructions generated can be viewed using:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e(define x '(define (test2 chan)\n             (define msg (wait chan))\n             (test2 chan)))\n(define code (compile x))\n(for-each (lambda (x) (print* (format x) \"\\n\")) code)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eUsing \u003ccode\u003ecompile\u003c/code\u003e shows the first pass which does not look for tail calls:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e(newf)\n(ldg test2)\n(arg)\n(ldg chan)\n(arg)\n(call)\n(retn)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eNotice the \u003ccode\u003ecall\u003c/code\u003e followed by \u003ccode\u003eretn\u003c/code\u003e. This is the sequence that \u003ccode\u003eoptimize\u003c/code\u003e looks for to generate the \u003ccode\u003etail\u003c/code\u003e instruction:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e(define x '(define (test2 chan)\n             (define msg (wait chan))\n             (test2 chan)))\n(define code (optimize (compile x)))\n(for-each (lambda (x) (print* (format x) \"\\n\")) code)\n...\n(newf)\n(ldg test2)\n(arg)\n(ldg chan)\n(arg)\n(tail)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eLooking back at the instructions for \u003ccode\u003etest1\u003c/code\u003e the \u003ccode\u003ecall\u003c/code\u003e is followed by a jump or a label before \u003ccode\u003eretn\u003c/code\u003e so the optimizer misses it. This can be worked around by doing an explicit \u003ccode\u003ereturn\u003c/code\u003e statement:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e(define (test3 chan)\n  (define msg (wait chan))\n  (cond\n    ((eq msg 'foo)\n      (return (test1 chan)))\n    ((eq msg 'bar)\n      (return (test1 chan)))\n    (else\n      (return (test1 chan)))))\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe code in the \u003ccode\u003econd\u003c/code\u003e branches generates to the following which is now a tail call:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e(jf false-93)\n(newf)\n(ldg test1)\n(arg)\n(ldg chan)\n(arg)\n(tail)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch2\u003eSome things to note\u003c/h2\u003e\n\n\u003cp\u003eThe Wasp VM is single threaded and non-preemptive. Threads yield to the scheduler explicitly using \u003ccode\u003eyield\u003c/code\u003e or implicitly when doing i/o or waiting on a queue. The bytecode is cross platform. Serialized objects on one architecture can be deserialized on another. The Wasp VM history comes from Mosquito Lisp and MOSREF - a penetration testing platform. It's written in C with some GNU extensions (nested functions are used in the VM).\u003c/p\u003e\n\n\u003cp\u003eThis post came about from exploring the difference in Actor programming in the \u003ca href=\"http://www.ponylang.org/\"\u003ePony programming language\u003c/a\u003e and a dynamic language where the Actor model isn't explicit. The programming style is similar in that pipelines of calls to actors to transform data is a common idiom.\u003c/p\u003e\n\n\u003cp\u003eWasp Lisp isn't actively developed anymore but the author, Scott Dunlop, still processes pull requests and monitors it. I like to use it for projects and tinker with it as it's an interesting little cross platform lisp. MOSREF is useful as a way to access and maintain servers of different architectures, aside from its use as a penetration testing tool.\u003c/p\u003e\n\n\u003cp\u003eSome other Wasp resources:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://sites.google.com/site/waspvm/\"\u003eWasp Lisp main site\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://waspvm.blogspot.com\"\u003eWasp Developments Blog\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/swdunlop/WaspVM/\"\u003eSource on Github\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://web.archive.org/web/20070208062534/http://www.ephemeralsecurity.com/lisp\"\u003eEphemeral Security Mosquito Lisp\u003c/a\u003e on the Internet Archive Wayback Machine.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n      \u003cdiv\u003eTags: \n        \n          \u003ca href=\"./tags/waspvm/index.html\"\u003ewaspvm\u003c/a\u003e\u0026nbsp;\n        \n      \u003c/div\u003e\n      \u003c/div\u003e\n      \u003chr\u003e\n    \u003c/div\u003e\n  \n    \u003cdiv class=\"post\"\u003e\n      \u003cdiv class=\"span-2\"\u003e\u003cp class=\"small-heading\"\u003e2016-06-05\u003c/p\u003e\u003c/div\u003e\n      \u003cdiv class=\"span-18 last\"\u003e\n      \u003ch2 class=\"post-title\"\u003e\u003ca href=\"././2016/06/05/building-static-wasp-lisp-binaries.html\"\u003eBuilding Static Wasp Lisp Binaries on Linux\u003c/a\u003e\u003c/h2\u003e\n      \u003cp\u003e\u003ca href=\"./2009/11/27/wasp-lisp-small-scheme-like-lisp.html\"\u003eWasp Lisp\u003c/a\u003e builds binaries that are linked dynamically to \u003ca href=\"https://www.gnu.org/software/libc/\"\u003eglibc\u003c/a\u003e. This ties the binary to specific versions of Linux. It's usually not possible to run on an OS with older glibc versions than what it was compiled against. I wanted to be able to run a single binary of Wasp Lisp and \u003ca href=\"./2009/11/28/using-wasp-lisp-secure-remote-injection.html\"\u003eMOSREF\u003c/a\u003e drones on new Ubuntu versions and some machines with an older version of Ubuntu. To do this I needed to have the libc linked statically.\u003c/p\u003e\n\n\u003cp\u003eChanging Wasp Lisp to statically link glibc doesn't work though. Some networking routines in glibc \u003ca href=\"https://sourceware.org/glibc/wiki/FAQ#Even_statically_linked_programs_need_some_shared_libraries_which_is_not_acceptable_for_me.__What_can_I_do.3F\"\u003erequire dynamic linking\u003c/a\u003e. If glibc is statically linked then networking doesn't work.\u003c/p\u003e\n\n\u003cp\u003eThe solution I opted for is to use \u003ca href=\"https://www.musl-libc.org/\"\u003emusl libc\u003c/a\u003e instead of glibc. This is a libc that was designed to be statically linked. To buid Wasp Lisp binaries with musl it required:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eBuilding musl libc\u003c/li\u003e\n\u003cli\u003eBuilding libevent using musl libc headers\u003c/li\u003e\n\u003cli\u003eBuilding Wasp Lisp against musl and libevent\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\u003ch2\u003eBuilding musl libc\u003c/h2\u003e\n\n\u003cp\u003eBuilding musl libc requires using \u003ccode\u003egit\u003c/code\u003e to clone the repository and following the standard \u003ccode\u003econfigure\u003c/code\u003e, \u003ccode\u003emake\u003c/code\u003e, \u003ccode\u003emake install\u003c/code\u003e invocations. The \u003ccode\u003ebin\u003c/code\u003e directory for the musl tools is added to the \u003ccode\u003ePATH\u003c/code\u003e:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e$ git clone git://git.musl-libc.org/musl\n$ cd musl\n$ ./configure\n$ make\n$ sudo make install\n$ export PATH=$PATH:/usr/local/musl/bin/\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch2\u003eBuilding libevent\u003c/h2\u003e\n\n\u003cp\u003eBuilding libevent with musl requires using the \u003ccode\u003emusl-gcc\u003c/code\u003e command which was installed by the previous step. This invokes GCC with the required options to use musl. The following steps performs the build:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e$ wget https://github.com/libevent/libevent/releases/download/release-2.0.22-stable/libevent-2.0.22-stable.tar.gz\n$ tar xvf libevent-2.0.22-stable.tar.gz\n$ cd libevent-2.0.22-stable/\n$ ./configure --prefix=/tmp/musl/usr CC=musl-gcc --enable-static --disable-shared\n$ make\n$ make install\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch2\u003eBuilding Wasp Lisp\u003c/h2\u003e\n\n\u003cp\u003eThe Wasp VM source requires a change to the \u003ccode\u003eMakefile.cf\u003c/code\u003e to use static linking for all libraries. This changes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eEXEFLAGS += -Wl,-Bstatic $(STATICLIBS) -Wl,-Bdynamic $(DYNAMICLIBS)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eto:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eEXEFLAGS += -static $(STATICLIBS) $(DYNAMICLIBS)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eI've made this change in the \u003ccode\u003estatic\u003c/code\u003e branch of my \u003ca href=\"https://github.com/doublec/waspvm\"\u003egithub fork \u003c/a\u003e. This branch also includes some other changes from the \u003ca href=\"https://github.com/swdunlop/WaspVM\"\u003eofficial repository\u003c/a\u003e for real number support. Building with musl and libevent is done with:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e$ git clone https://github.com/doublec/WaspVM --branch static\n$ cd WaspVM\n$ CC=musl-gcc CFLAGS=\"-I /tmp/musl/usr/include -L /tmp/musl/usr/lib\" make repl\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThis runs directly into the Lisp REPL. The following confirms a static binary:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e$ ldd wasp\nnot a dynamic executable\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch2\u003eBuilding MOSREF\u003c/h2\u003e\n\n\u003cp\u003eThe stub generated is also static and can be used to build static drones:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e$ cd mod\n$ ../waspc -exe ../mosref bin/mosref\n$ chmod +x ../mosref\n$ ../mosref\nconsole\u0026gt; set addr=xx.xx.xx.xx\nconsole\u0026gt; set port=8000\nconsole\u0026gt; drone mydrone foo linux-x86_64\nDrone executable created.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe generated drone should run on a wider range of Linux versions than the non-static build at the cost of a larger size. I rename the \u003ccode\u003ewaspvm-linux-x86_64\u003c/code\u003e stub to be \u003ccode\u003ewaspvm-musl-x86-64\u003c/code\u003e so I can generate static drones or dynamic linked drones as needed from the MOSREF console by using \u003ccode\u003elinux-x86_64\u003c/code\u003e or \u003ccode\u003emusl-x86_64\u003c/code\u003e respectively.\u003c/p\u003e\n\n      \u003cdiv\u003eTags: \n        \n          \u003ca href=\"./tags/waspvm/index.html\"\u003ewaspvm\u003c/a\u003e\u0026nbsp;\n        \n      \u003c/div\u003e\n      \u003c/div\u003e\n      \u003chr\u003e\n    \u003c/div\u003e\n  \n    \u003cdiv class=\"post\"\u003e\n      \u003cdiv class=\"span-2\"\u003e\u003cp class=\"small-heading\"\u003e2016-05-11\u003c/p\u003e\u003c/div\u003e\n      \u003cdiv class=\"span-18 last\"\u003e\n      \u003ch2 class=\"post-title\"\u003e\u003ca href=\"././2016/05/11/exploring-actors-in-pony.html\"\u003eExploring actors in Pony\u003c/a\u003e\u003c/h2\u003e\n      \u003cp\u003e\u003ca href=\"http://ponylang.org\"\u003ePony\u003c/a\u003e is an actor oriented programming language. In Pony Actors are objects that can send and receive messages asychronously while processing their received messages sequentially and in parallel with other actors processing their messages. They are the unit of concurrency in the language. Each actor is similar to a lightweight thread of execution in languages that support those.\u003c/p\u003e\n\n\u003cp\u003eFor background on the Actor model of computation there are a lot of papers at the \u003ca href=\"http://erights.org/history/actors.html\"\u003eerights.org actor page\u003c/a\u003e. They make good background reading. In this post I'm going to go through some things I've learnt while learning Pony and using actors in some small projects.\u003c/p\u003e\n\n\u003cp\u003eAn \u003ccode\u003eactor\u003c/code\u003e is defined very similar to a \u003ccode\u003eclass\u003c/code\u003e. The following class definition creates a counter that can be incremented and decremented:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eclass Counter\n  var count: U32\n\n  new create(start: U32) =\u0026gt;\n    count = 0\n\n  fun ref inc() =\u0026gt;\n    count = count + 1\n\n  fun ref dec() =\u0026gt;\n    count = count - 1\n\n  fun get(): U32 =\u0026gt;\n    count\n\nactor Main\n  new create(env: Env) =\u0026gt;\n    let c1 = Counter(0)\n    c1.inc()\n    c1.inc()\n    env.out.print(c1.get().string())\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe first thing to note here is the actor called \u003ccode\u003eMain\u003c/code\u003e. Every Pony program has an actor called \u003ccode\u003eMain\u003c/code\u003e that is the entry point for the program. This actor is instantiated by the Pony runtime and the constructor is expected to perform the program operations in a similar manner to how the \u003ccode\u003emain\u003c/code\u003e functions works in the \u003ccode\u003eC\u003c/code\u003e programming language.\u003c/p\u003e\n\n\u003cp\u003eThe \u003ccode\u003eCounter\u003c/code\u003e class is created in the constructor of \u003ccode\u003eMain\u003c/code\u003e and incremented a couple of times. All this happens in a single thread of control. Because it operates within a single thread there is no concurrent access to the state held by the counter. This makes it safe to call the \u003ccode\u003einc\u003c/code\u003e, \u003ccode\u003edec\u003c/code\u003e and \u003ccode\u003eget\u003c/code\u003e methods. The order of operations is well defined. We can only pass the counter instance to another thread if we give up any aliases to it so we can ensure that it can be safely used elsewhere or if we make it immutable so that nothing can change it at any time.\u003c/p\u003e\n\n\u003ch2\u003eBehaviours\u003c/h2\u003e\n\n\u003cp\u003eIf we want to use a \u003ccode\u003eCounter\u003c/code\u003e from multiple threads but still allow modification then making it an actor is an option. This can be done by changing the \u003ccode\u003eclass\u003c/code\u003e keyword to \u003ccode\u003eactor\u003c/code\u003e and the methods to behaviours:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eactor Counter\n  var count: U32\n\n  new create(start: U32) =\u0026gt;\n    count = 0\n\n  be inc() =\u0026gt;\n    count = count + 1\n\n  be dec() =\u0026gt;\n    count = count - 1\n\n  be display(out:OutStream) =\u0026gt;\n    out.print(count.string())\n\nactor Main\n  new create(env: Env) =\u0026gt;\n    let c1 = Counter(0)\n    c1.inc()\n    c1.inc()\n    c1.display(env.out)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eA behaviour is introduced with the \u003ccode\u003ebe\u003c/code\u003e keyword. It is like a function except that it is asynchronous. When a behaviour is called it is not executed immediately.\u003c/p\u003e\n\n\u003cp\u003eInternally each actor has a queue for holding messages. Each behaviour call on an actor puts a message in that queue to run that behaviour at some future point in time. The actor runs a message loop that pops a message off the queue and runs the associated behaviour. When the behaviour completes executing then it will run the next one in the queue for that actor. If there are none left to run the the actor is idle until a behaviour is called. During this idle period it can perform garbage collection. The Pony runtime has a scheduler that uses operating system threads to execute actor behaviours. In this way multiple behaviours for different actors can be running on many OS threads at the same time.\u003c/p\u003e\n\n\u003cp\u003eThe behaviours that are queued for an individual actor are executed sequentially. Two behaviours for the same actor will never run concurrently. This means that within a behaviour the actor has exclusive access to its internal state. There is no need for locks or guards to control access. For this reason it helps to think of actors as a unit of sequentiality rather than of a parallelism. See the \u003ca href=\"http://tutorial.ponylang.org/types/actors.html\"\u003eactors section of the tutorial\u003c/a\u003e for more on this.\u003c/p\u003e\n\n\u003cp\u003eThe main change with the conversion of the counter class is there is no longer a \u003ccode\u003eget\u003c/code\u003e method. It's replaced by a \u003ccode\u003edisplay\u003c/code\u003e behaviour that outputs the string. \u003ccode\u003eget\u003c/code\u003e was removed because behaviours are executed asynchronously so they cannot return the result of the function - they've returned to the caller before the body of the behaviour is executed. They always return the object the behaviour was called on. This makes chaining behaviour calls possible:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e    let c1 = Counter(0)\n    c1.inc()\n      .inc()\n      .display(env.out)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch2\u003etag reference capability\u003c/h2\u003e\n\n\u003cp\u003eA \u003ccode\u003eclass\u003c/code\u003e defaults to a reference capability of \u003ca href=\"http://tutorial.ponylang.org/capabilities/reference-capabilities.html\"\u003eref\u003c/a\u003e. An \u003ccode\u003eactor\u003c/code\u003e defaults to \u003ccode\u003etag\u003c/code\u003e. A \u003ccode\u003etag\u003c/code\u003e only allows object identification. No read or write operations are allowed but you can alias \u003ccode\u003etag\u003c/code\u003e objects and you can pass them to other actors. This is safe since the holder of a \u003ccode\u003etag\u003c/code\u003e alias can't view or modify the state. It can call behaviours on it though. This is safe because behaviours are queued for sequential processing at a future point in time - access to the state of the actor is serialized through behaviours.\u003c/p\u003e\n\n\u003ch2\u003eSimulating return values\u003c/h2\u003e\n\n\u003cp\u003eHow do you deal with returning values from behaviours if they don't support return values? One approach is to pass an object to the behaviour that it uses as a callback with the result. For the counter example this could look like:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eactor Counter\n  ...as before...\n\n  be get(cb: {(U32)} iso) =\u0026gt;\n    cb(count)\n\nactor Main\n  new create(env: Env) =\u0026gt;\n    let c1 = Counter(0)\n    c1.inc()\n      .inc()\n      .get(recover lambda (x:U32)(env) =\u0026gt; env.out.print(x.string()) end end)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eHere the \u003ccode\u003eget\u003c/code\u003e behaviour receives a \u003ca href=\"./2016/03/15/closures-in-pony.html\"\u003eclosure\u003c/a\u003e as an argument. This is called passing a closure that prints the value out. When \u003ccode\u003eget\u003c/code\u003e is executed asynchronously it's safe for it to pass the \u003ccode\u003ecount\u003c/code\u003e value to the closure. The closure can't modify it. The closure itself is an \u003ccode\u003eiso\u003c/code\u003e reference capability so nothing else but the behaviour is accessing it.\u003c/p\u003e\n\n\u003cp\u003eThis approach leads to a very 'callback' style of programming. It can feel like programming in \u003ca href=\"https://en.wikipedia.org/wiki/Continuation-passing_style\"\u003econtinuation passing style\u003c/a\u003e at times. It requires careful design when dealing with error handling. Pony includes a \u003ccode\u003epromises\u003c/code\u003e library to help manage this.\u003c/p\u003e\n\n\u003ch3\u003ePromises\u003c/h3\u003e\n\n\u003cp\u003eThe promises library provides the ability to pass callbacks, handle errors and chain promises together to make it easier to manage callback style programming. The counter example converted to use promoses looks like:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003euse \"promises\"\n\nactor Counter\n  ...as before...\n\n  be get(p: Promise[U32]) =\u0026gt;\n    p(count) \n\nactor Main\n  new create(env: Env) =\u0026gt;\n    let c1 = Counter(0)\n    let p = Promise[U32]\n    c1.inc()\n      .inc()\n      .get(p)\n    p.next[None](recover lambda ref(x:U32)(env) =\u0026gt; env.out.print(x.string()) end end)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe \u003ccode\u003eget\u003c/code\u003e method has been changed to take a \u003ccode\u003ePromise[U32]\u003c/code\u003e. The \u003ccode\u003ePromise\u003c/code\u003e type is a generic type and here it is indexed over the \u003ccode\u003eU32\u003c/code\u003e value that it will be provided with. In the \u003ccode\u003eMain\u003c/code\u003e actor a promise is created and passed to \u003ccode\u003eget\u003c/code\u003e. Then the \u003ccode\u003enext\u003c/code\u003e method is called on the promise to tell it what to do when a value is provided to it. In this case it's the same closure as in the previous example so there's not much of a win here.\u003c/p\u003e\n\n\u003cp\u003eWhat promises do provide though is a way to handle failure. A callback used in the promise can \u003ca href=\"http://tutorial.ponylang.org/expressions/exceptions.html\"\u003eraise an error\u003c/a\u003e and the promise will try the next operation in the chain. Chained promises can manipulate values as they're passed down the chain to form a pipeline of operations.\u003c/p\u003e\n\n\u003cp\u003eThe boilerplate to create the promise and pass it to the behaviour can be hidden by a method on the actor:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eactor Counter\n  ...as before...\n\n  be myget(p: Promise[U32]) =\u0026gt;\n    p(count)\n\n  fun tag get(): Promise[U32] =\u0026gt;\n    let p = Promise[U32]\n    myget(p)\n    p\n\nactor Main\n  new create(env: Env) =\u0026gt;\n    let c1 = Counter(0)\n    c1.inc()\n      .inc()\n      .get().next[None](recover lambda ref(x:U32)(env) =\u0026gt; env.out.print(x.string()) end end)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eIn this example the \u003ccode\u003eget\u003c/code\u003e method creates the promise and passes it to the behaviour then returns the promise. The caller can then use method chaining to call \u003ccode\u003enext\u003c/code\u003e on the promise to perform the action.\u003c/p\u003e\n\n\u003cp\u003eNotice that the \u003ccode\u003eget\u003c/code\u003e method has a \u003ccode\u003etag\u003c/code\u003e reference capability. This is required to allow other actors to call it. A reference to an actor has the \u003ccode\u003etag\u003c/code\u003e capability so only behaviours and \u003ccode\u003etag\u003c/code\u003e methods can be called with it. A \u003ccode\u003etag\u003c/code\u003e method can't modify internal state - all it can do is call behaviours on the actor - so this is safe to be called externally. It would be a compile error if the method attempted to view or modify actor state.\u003c/p\u003e\n\n\u003cp\u003eThe following demonstrates promise chaining:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eactor Counter\n  ...as before...\n\n  fun tag get_string(): Promise[String] =\u0026gt;\n    get().next[String](object iso\n                         fun ref apply(x:U32): String =\u0026gt; x.string()\n                       end)\n\nactor Main\n  new create(env: Env) =\u0026gt;\n    let c1 = Counter(0)\n    c1.inc()\n      .inc()\n      .get_string().next[Main](recover this~print(env.out) end)\n\n  be print(out:OutStream, s: String) =\u0026gt;\n    out.print(s)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eIn this case we want a \u003ccode\u003eString\u003c/code\u003e from the behaviour call. The \u003ccode\u003eget_string\u003c/code\u003e method on \u003ccode\u003eCounter\u003c/code\u003e calls \u003ccode\u003eget\u003c/code\u003e and chains the \u003ccode\u003enext\u003c/code\u003e callback to be one that returns a result of type `String. It just does a conversion by calling  the string method. I use an object literal here instead of a closure for clarity.\u003c/p\u003e\n\n\u003cp\u003eThe caller in \u003ccode\u003eMain\u003c/code\u003e calls \u003ccode\u003eget_string\u003c/code\u003e and chains the returned promise with another callback. This callback uses \u003ca href=\"http://tutorial.ponylang.org/expressions/partial-application.htmlhttp://tutorial.ponylang.org/expressions/partial-application.html\"\u003epartial application\u003c/a\u003e to call the \u003ccode\u003eprint\u003c/code\u003e behaviour on \u003ccode\u003eMain\u003c/code\u003e to print the string. The \u003ccode\u003enext\u003c/code\u003e call uses \u003ccode\u003eMain\u003c/code\u003e to parameterize the promise result as calling the \u003ccode\u003eprint\u003c/code\u003e behaviour returns the receiver - in this case \u003ccode\u003eMain\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThe result of this is that when the \u003ccode\u003eget\u003c/code\u003e behaviour is executed it calls the first promise in the chain to return the result. That converts the \u003ccode\u003eU32\u003c/code\u003e to a \u003ccode\u003eString\u003c/code\u003e. The next promise in the chain is then called which calls \u003ccode\u003eprint\u003c/code\u003e on the \u003ccode\u003eMain\u003c/code\u003e actor. That behaviour gets queued and eventually run to output the result.\u003c/p\u003e\n\n\u003cp\u003eWhich is best to use, promises or callbacks? It depends on what the objects are doing. For single return values with an error case then promises are a good approach. For objects that need to callback multiple times then a callback or notifier object may be a better choice. For an example of the latter, see the \u003ccode\u003enet\u003c/code\u003e packages use of various notifier classes like \u003ccode\u003eTCPConnectionNotify\u003c/code\u003e to provide notification of different states in the TCP connection lifetime:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003einterface TCPConnectionNotify\n  fun ref accepted(conn: TCPConnection ref)\n  fun ref connecting(conn: TCPConnection ref, count: U32)\n  fun ref connected(conn: TCPConnection ref)\n  fun ref connect_failed(conn: TCPConnection ref)\n  fun ref auth_failed(conn: TCPConnection ref)\n  fun ref sent(conn: TCPConnection ref, data: ByteSeq): ByteSeq ?\n  fun ref sentv(conn: TCPConnection ref, data: ByteSeqIter): ByteSeqIter ?\n  fun ref received(conn: TCPConnection ref, data: Array[U8] iso)\n  fun ref expect(conn: TCPConnection ref, qty: USize): USize\n  fun ref closed(conn: TCPConnection ref)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch2\u003eSendable objects\u003c/h2\u003e\n\n\u003cp\u003eAs behaviours are sent asycnhronously this means the arguments to those behaviours must be sharable. The \u003ca href=\"http://tutorial.ponylang.org/capabilities/passing-and-sharing.html\"\u003epassing and sharing\u003c/a\u003e section of the tutorial makes the distinction between 'passing' and 'sharing' objects.\u003c/p\u003e\n\n\u003cp\u003eIn 'passing' an object from one actor to another the originating actor is giving up ownership. It can no longer access the object after giving it to the receiving actor. This is the \u003ccode\u003eiso\u003c/code\u003e reference capability. The sending actor must consume it when passing it to the receiver:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eactor Main\n  new create(env: Env) =\u0026gt;\n    let a = recover iso String end\n    let b = Something\n    b.doit(consume a)\n\nactor Something\n  be doit(s: String iso) =\u0026gt;\n    s.append(\"Hello World\")\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eIn 'sharing' an object you want both the originating actor and the receiver (and any others) to be able to read from the object. Nothing should be able to write to it. This is the \u003ccode\u003eval\u003c/code\u003e reference capability:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eclass Data\n  var count: U32 = 0\n\n  fun ref inc() =\u0026gt;\n    count = count + 1\n\nactor Main\n  new create(env: Env) =\u0026gt;\n    let a: Data trn = recover trn Data end\n    a.inc()\n\n    let d: Data val = consume a\n    let s1 = Something(env.out)\n    let s2 = Something(env.out)\n    s1.doit(d)\n    s2.doit(d)\n\nactor Something\n  let _out: OutStream\n\n  new create(out: OutStream) =\u0026gt;\n    _out = out\n\n  be doit(d: Data val) =\u0026gt;\n    _out.print(\"Got \" + d.count.string())\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThis example has a \u003ccode\u003eData\u003c/code\u003e class with an integer \u003ccode\u003ecount\u003c/code\u003e field. In the \u003ccode\u003eMain\u003c/code\u003e actor we create an instance as a \u003ccode\u003etrn\u003c/code\u003e reference capability. This is used for objects that you want to write to initially but give out immutable access to later. While we hold the mutable \u003ccode\u003etrn\u003c/code\u003e reference we increment it and then consume it to get an immutable \u003ccode\u003eval\u003c/code\u003e reference capability for it. The old \u003ccode\u003ea\u003c/code\u003e alias is no longer usable at this point - no writeable aliases to the object exist. Because it is immutable we can now pass it to as many actors as we want and they get read only access to the objects fields and methods.\u003c/p\u003e\n\n\u003cp\u003eAnother sharable type is the \u003ccode\u003etag\u003c/code\u003e reference capability. This provides only identity access to an object. A receiver of a \u003ccode\u003etag\u003c/code\u003e object can't read or write fields but it can call behaviours. It is the reference capability used for actors and is what you use to pass actors around. The previous sharing example uses this to pass the \u003ccode\u003eenv.out\u003c/code\u003e object around. The \u003ccode\u003eOutStream\u003c/code\u003e is an actor.\u003c/p\u003e\n\n\u003cp\u003eIt's important to keep in mind that creating aliases of objects doesn't copy the object. It's a new variable pointing to the same object. There is no copy operation involved in passing the \u003ccode\u003eData val\u003c/code\u003e objects around. Although the capability is called 'val' it is not a '\u003ca href=\"https://en.wikipedia.org/wiki/Value_object\"\u003evalue object\u003c/a\u003e'. The two \u003ccode\u003eSomething\u003c/code\u003e actors have the same \u003ccode\u003eData\u003c/code\u003e object in terms of object identity. The \u003ccode\u003eval\u003c/code\u003e only means 'immutable'.\u003c/p\u003e\n\n\u003cp\u003eThe reference capabilities and the checking by the type system is what allows avoiding copies to be safe in the presence of multiple actors. This does mean that if you have a \u003ccode\u003eref\u003c/code\u003e object you can't pass it to an actor. This is a compile error:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eactor Something\n  be doit(s: String ref) =\u0026gt;\n  None\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eOnly \u003ccode\u003eval\u003c/code\u003e, \u003ccode\u003eiso\u003c/code\u003e and \u003ccode\u003etag\u003c/code\u003e can be used as an argument to a behaviour. This will also fail to compile:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eactor Main\n  new create(env: Env) =\u0026gt;\n    let a = recover ref String end\n    a.append(\"Hello World\")\n    let b = Something\n    b.doit(a)\n\nactor Something\n  be doit(s: String val) =\u0026gt;\n    None\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eHere we have a \u003ccode\u003eString ref\u003c/code\u003e and are trying to pass it to a behaviour expecting a \u003ccode\u003eString val\u003c/code\u003e. It is not possible to convert a \u003ccode\u003eref\u003c/code\u003e to a \u003ccode\u003eval\u003c/code\u003e. A \u003ccode\u003eref\u003c/code\u003e provides read and write access to the object. Multiple aliases to the same \u003ccode\u003eref\u003c/code\u003e object can exist within a single actor. This is safe because behaviour execution within an actor is sequential. All of these aliases would need to be consumed to safely get a \u003ccode\u003eval\u003c/code\u003e alias. The type system doesn't (and probably couldn't) prove that all aliases are consumed at the time of converting to a \u003ccode\u003eval\u003c/code\u003e so it is not possible to do the conversion.\u003c/p\u003e\n\n\u003cp\u003eThis is a case where a copy is needed:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eactor Main\n  new create(env: Env) =\u0026gt;\n    let a = recover ref String end\n    a.append(\"Hello World\")\n    let b = Something\n    b.doit(a.clone())\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe \u003ccode\u003eclone\u003c/code\u003e method on \u003ccode\u003eString\u003c/code\u003e returns a \u003ccode\u003eString iso^\u003c/code\u003e which is convertable automatically to a \u003ccode\u003eString val\u003c/code\u003e by virtue of the fact that it has no aliases (The \u003ccode\u003e^\u003c/code\u003e part of the type). See \u003ca href=\"http://tutorial.ponylang.org/capabilities/capability-subtyping.html\"\u003ecapability subtyping\u003c/a\u003e for details\u003c/p\u003e\n\n\u003cp\u003eCloning creates a copy distinct from the original. They have different identities and is a less efficient operation so it's worthwhile examining the data being passed around and seeing if it's possible to avoid holding multiple references to data and use the strictest reference capability to avoid aliasing.\u003c/p\u003e\n\n\u003ch2\u003eBlocking operations\u003c/h2\u003e\n\n\u003cp\u003ePony has no blocking operations (outside of using the C FFI). In languages like \u003ca href=\"http://www.erlang.org/\"\u003eErlang\u003c/a\u003e it's common to do a blocking receive within a function to wait for a message and operate on it. In Pony this is implicitly done by actors in their event loop, hidden from the programmer. A behaviour call queues the message and it is executed when it's popped off the queue. You can't block for a message within the body of a behaviour itself.\u003c/p\u003e\n\n\u003cp\u003eThis results in having to change the programming mode from \"wait for data and do something\" to \"notify me of data when it's available\". Instead of blocking for N seconds within a behaviour you \u003ca href=\"http://patterns.ponylang.org/async/waiting.html\"\u003ecreate a timer to notify the actor\u003c/a\u003e of something 'N' seconds later.\u003c/p\u003e\n\n\u003cp\u003eThe Pony standard library is structured in this way to use notifier objects, callbacks and promises to make programming in this style easier.\u003c/p\u003e\n\n\u003ch2\u003eCausal Messaging\u003c/h2\u003e\n\n\u003cp\u003eData races can be difficult to avoid in the presence of asynchronous executation of threads. Pony has a message ordering guarantee to make the following type of code safe:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eactor Counter\n  let _out: OutStream\n  var count: U32 = 0\n\n  new create(out: OutStream) =\u0026gt;\n    _out = out\n\n  be inc() =\u0026gt;\n    count = count + 1\n\n  be dec() =\u0026gt;\n    count = count - 1\n    if count == 0 then _out.print(\"counter is destoyed\") end\n\nactor Something\n  be doit(counter: Counter) =\u0026gt;\n    counter.dec()\n\nactor Main\n  new create(env: Env) =\u0026gt;\n    let c1 = Counter(env.out)\n    let c2 = Something\n    c1.inc()\n    c2.doit(c1)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eIn this example the \u003ccode\u003eCounter\u003c/code\u003e object does something when the count is decremented to zero. In the \u003ccode\u003eMain\u003c/code\u003e actor a counter is created, incremented and passed to another actor where it is decremented. The \u003ccode\u003einc\u003c/code\u003e and \u003ccode\u003edoit\u003c/code\u003e calls are on different actors and therefore are executed asynchronously. It's important that the \u003ccode\u003einc\u003c/code\u003e call executes before the \u003ccode\u003edec\u003c/code\u003e call in the \u003ccode\u003edoit\u003c/code\u003e behaviour of the other actor.\u003c/p\u003e\n\n\u003cp\u003ePony has a message ordering guarantee, called 'causal messaging', to ensure this ordering happens. This is described in a \u003ca href=\"https://news.ycombinator.com/item?id=9483333\"\u003eforum thread discussion\u003c/a\u003e as:\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e[...] Pony makes a messaging order guarantee that's much stronger than is typical for the actor model. It guarantees causal messaging. That is, any message that is a \"cause\" of another message (i.e. was sent or received by an actor prior to the message in question) is guaranteed to arrive before the \"effect\" if they have the same destination.\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003eFor more information the paper \u003ca href=\"https://github.com/ponylang/ponylang.github.io/blob/master/papers/opsla237-clebsch.pdf\"\u003eFully Concurrent Garbage Collection of Actors on Many-Core Machines\u003c/a\u003e goes into detail about how it works.\u003c/p\u003e\n\n\u003ch2\u003eGarbage Collection\u003c/h2\u003e\n\n\u003cp\u003eActor's have their own garbage collection heap. Garbage collection occurs between behaviour calls on the actor. This allows GC to occur for an actor without interrupting execution of other actors. The runtime detects when it is no longer possible for an actor to receive messages and will garbage collect the actor itself. This can avoid the need to implement a 'poison pill' protocol whereby the actor receives a message to say it can terminate.\u003c/p\u003e\n\n\u003cp\u003eEven with this automatic actor garbage detection in place there are times when it is necessary to implement a shutdown protocol. An actor may be receiving notification callbacks - the actor sending the callbacks needs to be told to stop sending the messages so the system can detect that the receiver can be garbage collected. In my \u003ca href=\"https://github.com/doublec/imap-idler/blob/master/idle/main.pony\"\u003eIMAP Idle monitor\u003c/a\u003e I use \u003ca href=\"https://github.com/doublec/imap-idler/blob/9dc7b1e2fce8e6d3551952f141d4d5e71593e9c8/idle/main.pony#L165\"\u003edispose methods\u003c/a\u003e to cancel timers or \u003ca href=\"https://github.com/doublec/imap-idler/blob/9dc7b1e2fce8e6d3551952f141d4d5e71593e9c8/idle/main.pony#L319\"\u003eclose TCP connections\u003c/a\u003e. A Pony library class called a \u003ca href=\"https://github.com/doublec/imap-idler/blob/9dc7b1e2fce8e6d3551952f141d4d5e71593e9c8/idle/main.pony#L78\"\u003eCustodian\u003c/a\u003e holds a collection of actors to be disposed and calls \u003ccode\u003edispose\u003c/code\u003e on each one when its own \u003ccode\u003edispose\u003c/code\u003e behaviour is called. This results in the runtime detecting that none of the actors in the application can receive messages anymore and the entire application terminates.\u003c/p\u003e\n\n\u003cp\u003eOne thing to be careful of with garbage collection only happening between behaviour calls is that a long running behaviour will not GC during its execution. Simple benchmark applications that do everything in the \u003ccode\u003eMain\u003c/code\u003e actors constructor exhibit this. They use large amounts of memory due to no GC happening if the benchmark doesn't call a behaviour on the actor.\u003c/p\u003e\n\n      \u003cdiv\u003eTags: \n        \n          \u003ca href=\"./tags/pony/index.html\"\u003epony\u003c/a\u003e\u0026nbsp;\n        \n      \u003c/div\u003e\n      \u003c/div\u003e\n      \u003chr\u003e\n    \u003c/div\u003e\n  \n    \u003cdiv class=\"post\"\u003e\n      \u003cdiv class=\"span-2\"\u003e\u003cp class=\"small-heading\"\u003e2016-05-04\u003c/p\u003e\u003c/div\u003e\n      \u003cdiv class=\"span-18 last\"\u003e\n      \u003ch2 class=\"post-title\"\u003e\u003ca href=\"././2016/05/04/bang-hat-and-arrow-in-pony.html\"\u003eBang, Hat and Arrow in Pony\u003c/a\u003e\u003c/h2\u003e\n      \u003cp\u003eIf you've looked at \u003ca href=\"http://www.ponylang.org/\"\u003ePony programming language\u003c/a\u003e code you've probably seen use of punctuation symbols in places and wondered what they meant. This post is an attempt to explain three of those - the bang, hat and arrow (\u003ccode\u003e!\u003c/code\u003e, \u003ccode\u003e^\u003c/code\u003e and \u003ccode\u003e-\u0026gt;\u003c/code\u003e respectively). Note that this is my understanding based on usage, reading the tutorials and watching videos so there may be errors. I welcome corrections!\u003c/p\u003e\n\n\u003ch2\u003eBang\u003c/h2\u003e\n\n\u003cp\u003eThe bang symbol (otherwise known as an exclamation mark) combined with a type name can be thought of as the type of an \u003ca href=\"http://tutorial.ponylang.org/capabilities/aliasing.html\"\u003ealias\u003c/a\u003e of the given type. Having an alias of an object means having another reference to that object. So an alias to a \u003ccode\u003eString iso\u003c/code\u003e is of type \u003ccode\u003eString iso!\u003c/code\u003e. This matters mostly in generic code which will be explained later but it does come up in error messages.\u003c/p\u003e\n\n\u003cp\u003eIf you see \u003ccode\u003e!\u003c/code\u003e in an error message like \"iso! is not a subtype of iso\" this means you are probably trying to assign an object that cannot be aliased without first consuming it.\u003c/p\u003e\n\n\u003cp\u003eIf you see \u003ccode\u003e!\u003c/code\u003e in a type declaration in code like \"let foo: A!\" then you can read this as \"replace A! with a type that can safely hold an alias to A\". If \u003ccode\u003eA\u003c/code\u003e is a \u003ccode\u003eString iso\u003c/code\u003e then \u003ccode\u003eA!\u003c/code\u003e would be a \u003ccode\u003eString trn\u003c/code\u003e for example (following the rules for \u003ca href=\"http://tutorial.ponylang.org/capabilities/capability-subtyping.html\"\u003ealiased substitution\u003c/a\u003e.\u003c/p\u003e\n\n\u003ch3\u003eBang in errors\u003c/h3\u003e\n\n\u003cp\u003eThe following code demonstrates something that is often encountered by first time Pony users:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eclass Something\n\nactor Main\n  new create(env: Env) =\u0026gt;\n    let a = recover iso Something end\n    Foo(a)\n\nactor Foo\n  new create(s: Something iso) =\u0026gt;\n    None\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eHere we have a class called \u003ccode\u003eSomething\u003c/code\u003e. A new instance of it is created in the Main actor with reference capability \u003ccode\u003eiso\u003c/code\u003e. A new \u003ccode\u003eFoo\u003c/code\u003e actor is created passing this instance to it. This will fail to compile as we are aliasing the \u003ccode\u003eSomething\u003c/code\u003e object held in \u003ccode\u003ea\u003c/code\u003e. \u003ccode\u003ea\u003c/code\u003e holds a reference to it and the variable \u003ccode\u003es\u003c/code\u003e holding the argument to the \u003ccode\u003eFoo\u003c/code\u003e constructor is holding a reference to it at the same time. Objects with a reference capability of \u003ccode\u003eiso\u003c/code\u003e cannot have more than one reference to it. The error from the compiler will look like:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eError:\ne1/main.pony:6:9: argument not a subtype of parameter\n    Foo(a)\n        ^\n    Info:\n    e1/main.pony:9:14: parameter type: Something iso\n      new create(s: Something iso) =\u0026gt;\n                 ^\n    e1/main.pony:6:9: argument type: Something iso!\n        Foo(a)\n            ^\n    e1/main.pony:1:1: Something iso! is not a subtype of Something iso: iso! is not a subtype of iso\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThis error states that the expected type of the parameter for the \u003ccode\u003eFoo\u003c/code\u003e constructor is of type \u003ccode\u003eSomething iso\u003c/code\u003e but the type that we passed is a \u003ccode\u003eSomething iso!\u003c/code\u003e. It further explains things by noting that \u003ccode\u003eSomething iso!\u003c/code\u003e is not a subtype of \u003ccode\u003eSomething iso\u003c/code\u003e because \u003ccode\u003eiso!\u003c/code\u003e is not a subtype of \u003ccode\u003eiso\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eArmed with the knowledge that the bang symbol means the type for an alias this can be read as the argument passed was an alias to a \u003ccode\u003eSomething iso\u003c/code\u003e. This is an error as \u003ccode\u003eiso\u003c/code\u003e cannot be aliased - this is what \u003ccode\u003eiso! is not a subtype of iso\u003c/code\u003e means. The subtyping relationship for aliases is outlined in the \u003ca href=\"http://tutorial.ponylang.org/capabilities/capability-subtyping.html\"\u003eCapability Subtyping\u003c/a\u003e section of the tutorial.\u003c/p\u003e\n\n\u003cp\u003eThe code can be fixed by consuming the \u003ccode\u003ea\u003c/code\u003e so it is no longer aliased:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003elet a = recover iso Something end\nFoo(consume a)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch3\u003eBang in generics\u003c/h3\u003e\n\n\u003cp\u003eThe other place where you'll see the alias type is in generic code. The following non-generic code compiles fine:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eclass Something\n  let a: U8\n\n  new create(x: U8) =\u0026gt;\n    a = x\n\nactor Main\n  new create(env: Env) =\u0026gt;\n    let aint = Something(42)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003eU8\u003c/code\u003e defaults to \u003ccode\u003eval\u003c/code\u003e reference capability which can be aliased. This allows the assignment to the field \u003ccode\u003ea\u003c/code\u003e in \u003ccode\u003eSomething\u003c/code\u003e which is aliasing the \u003ccode\u003ex\u003c/code\u003e object. If we make this a generic so that any type can be used then it fails to compile:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eclass Something[A]\n  let a: A\n\n  new create(x: A) =\u0026gt;\n    a = x\n\nactor Main\n  new create(env: Env) =\u0026gt;\n    let aint = Something[U8](42)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe error is:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eError:\ne3/main.pony:5:7: right side must be a subtype of left side\n    a = x\n      ^\n    Info:\n    e3/main.pony:4:17: right side type: A #any !\n      new create(x: A) =\u0026gt;\n                    ^\n    e3/main.pony:5:5: left side type: A #any\n        a = x\n        ^\n    e3/main.pony:4:17: A #any ! is not a subtype of A #any: the subtype has no constraint\n      new create(x: A) =\u0026gt;\n                ^\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eFor now, ignore the \u003ccode\u003e#any\u003c/code\u003e  in the error message. I'll expand on this later but it's informing us that the type \u003ccode\u003eA\u003c/code\u003e is unconstrained and can have any reference capability.\u003c/p\u003e\n\n\u003cp\u003eThe error states that \u003ccode\u003ex\u003c/code\u003e is an \u003ccode\u003eA!\u003c/code\u003e but \u003ccode\u003ea\u003c/code\u003e is an \u003ccode\u003eA\u003c/code\u003e and \u003ccode\u003eA!\u003c/code\u003e is not a subtype of \u003ccode\u003eA\u003c/code\u003e so the assignment cannot happen.\u003c/p\u003e\n\n\u003cp\u003eThis occurs Because \u003ccode\u003eA\u003c/code\u003e is unconstrained. It can be any reference capability. Therefore the code must be able to be compiled under the assumption that the most restrictive reference capability can be used. It works fine with \u003ccode\u003eval\u003c/code\u003e, which can be aliased, but not with \u003ccode\u003eiso\u003c/code\u003e which cannot. Therefore the generic code cannot be compiled. You can see how \u003ccode\u003eiso\u003c/code\u003e would fail by expanding a version using \u003ccode\u003eString iso\u003c/code\u003e:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eclass Something\n  let a: String  iso\n\n  new create(x: String iso) =\u0026gt;\n    a = x\n\nactor Main\n  new create(env: Env) =\u0026gt;\n    let aint = Something(recover iso String end)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe error is:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eError:\ne5/main.pony:5:7: right side must be a subtype of left side\n    a = x\n      ^\n    Info:\n    e5/main.pony:4:17: right side type: String iso!\n      new create(x: String iso) =\u0026gt;\n                    ^\n    e5/main.pony:2:10: left side type: String iso\n      let a: String  iso\n             ^\n    e5/main.pony:4:17: String iso! is not a subtype of String iso: iso! is not a subtype of iso\n      new create(x: String iso) =\u0026gt;\n                    ^\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThis is the same error that the generic code is giving us. The generic code can be fixed in a few ways. The first is to constrain the type so that it is a specific reference capability that works. Here it is changed to \u003ccode\u003eval\u003c/code\u003e:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eclass Something[A: Any val]\n  let a: A\n\n  new create(x: A) =\u0026gt;\n    a = x\n\nactor Main\n  new create(env: Env) =\u0026gt;\n    let aint = Something[U8](42)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe \u003ccode\u003eA: Any val\u003c/code\u003e syntax constrains the type parameter to be a subtype of the type after the \u003ccode\u003e:\u003c/code\u003e. In this case, any type with a reference capability of val. This won't work if you want to be able to use any aliasable type (eg \u003ccode\u003eref\u003c/code\u003e as well as \u003ccode\u003eval\u003c/code\u003e):\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eclass Something[A: Any val]\n  let a: A\n\n  new create(x: A) =\u0026gt;\n    a = x\n\nactor Main\n  new create(env: Env) =\u0026gt;\n    let aint = Something[U8](42)\n    let bint = Something[String ref](recover ref String end)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe error here is obvious in that we are trying to pass a \u003ccode\u003eref\u003c/code\u003e parameter to a function expecting a \u003ccode\u003eval\u003c/code\u003e. Pony generics solves this by allowing code to be polymorphic over the reference capability. There are specific annotations for classes of reference capabilities. They are:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e#read  = { ref, val, box }                = Anything you can read from\n#send  = { iso, val, tag }                = Anything you can send to an actor\n#share = { val, tag }                     = Anything you can send to more than one actor\n#any   = { iso, trn, ref, val, box, tag } = Default of a constraint\n#alias = {ref,val, box, tag}              = Set of capabilities that alias as themselves (used by compiler)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eA version that will work for \u003ccode\u003eref\u003c/code\u003e, \u003ccode\u003eval\u003c/code\u003e and \u003ccode\u003ebox\u003c/code\u003e becomes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eclass Something[A: Any #read]\n  let a: A\n\n  new create(x: A) =\u0026gt;\n    a = x\n\nactor Main\n  new create(env: Env) =\u0026gt;\n    let aint = Something[U8](42)\n    let bint = Something[String ref](recover ref String end)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eBut what if you want it to work with non-aliasable types like \u003ccode\u003eiso\u003c/code\u003e? A solution is to \u003ccode\u003econsume\u003c/code\u003e the parameter:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eclass Something[A]\n  let a: A\n\n  new create(x: A) =\u0026gt;\n    a = consume x\n\nactor Main\n  new create(env: Env) =\u0026gt;\n    let aint = Something[U8](42)\n    let bint = Something[String ref](recover ref String end)\n    let cint = Something[String iso](recover iso String end)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eAnother solution is to declare the field type to be \u003ccode\u003eA!\u003c/code\u003e instead of \u003ccode\u003eA\u003c/code\u003e. In the \u003ccode\u003eString iso\u003c/code\u003e case using \u003ccode\u003eA\u003c/code\u003e means \u003ccode\u003eString iso\u003c/code\u003e which cannot hold an alias. Using \u003ccode\u003eA!\u003c/code\u003e means \u003ccode\u003eString iso!\u003c/code\u003e which should be read as \"a type that can safely alias a \u003ccode\u003eString iso\u003c/code\u003e\". Looking at the \u003ca href=\"http://tutorial.ponylang.org/capabilities/capability-subtyping.html\"\u003eAliased substitution\u003c/a\u003e table this is a \u003ccode\u003etag\u003c/code\u003e:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eclass Something[A]\n  let a: A!\n\n  new create(x: A) =\u0026gt;\n    a = x\n\nactor Main\n  new create(env: Env) =\u0026gt;\n    let aint = Something[U8](42)\n    let bint = Something[String ref](recover ref String end)\n    let cint = Something[String iso](recover iso String end)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eIn this case we are using \u003ccode\u003e!\u003c/code\u003e to tell the compiler to use a reference capability that works for whatever the type of \u003ccode\u003eA\u003c/code\u003e is. An \u003ccode\u003eiso\u003c/code\u003e becomes a \u003ccode\u003etag\u003c/code\u003e, a \u003ccode\u003etrn\u003c/code\u003e becomes a \u003ccode\u003ebox\u003c/code\u003e, a \u003ccode\u003eref\u003c/code\u003e stays a \u003ccode\u003eref\u003c/code\u003e, etc.\u003c/p\u003e\n\n\u003ch2\u003eHat\u003c/h2\u003e\n\n\u003cp\u003eThe hat symbol (or \u003ccode\u003e^\u003c/code\u003e) is an \u003ca href=\"http://tutorial.ponylang.org/capabilities/aliasing.html\"\u003eephemeral type\u003c/a\u003e. It's the type of an object that is not assigned to a variable. \u003ccode\u003econsume x\u003c/code\u003e is used to prevent aliasing of \u003ccode\u003ex\u003c/code\u003e but at the point of being consumed and before it is assigned to anything else, what type is it? If \u003ccode\u003ex\u003c/code\u003e is type \u003ccode\u003eA\u003c/code\u003e then the type of \u003ccode\u003econsume x\u003c/code\u003e is \u003ccode\u003eA^\u003c/code\u003e. Constructors always return an ephemeral type as they create objects and return them but they aren't yet assigned to anything.\u003c/p\u003e\n\n\u003cp\u003eThe following example creates a \u003ccode\u003eBox\u003c/code\u003e type that acts like single instance array of \u003ccode\u003eString iso\u003c/code\u003e objects. A value can be stored and updated. A utility function \u003ccode\u003eFoo.doit\u003c/code\u003e takes a \u003ccode\u003eString iso\u003c/code\u003e as an argument. It's stubbed out since it doesn't need to do anything for the example. The main code creates a \u003ccode\u003eBox\u003c/code\u003e, updates it, and calls the utility function on it.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eclass Box\n  var a: String iso\n\n  new create(x: String iso) =\u0026gt;\n    a = consume x\n\n  fun ref update(x: String iso): String iso =\u0026gt;\n    let b = a = consume x\n    consume b\n\nprimitive Foo\n  fun doit(s: String iso) =\u0026gt;\n    None\n\nactor Main\n  new create(env: Env) =\u0026gt;\n    let a = Box(recover iso String end)\n    let b = a.update(recover iso String end)\n    Foo.doit(consume b)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eSome things to note based on prior discussion. The \u003ccode\u003ecreate\u003c/code\u003e method consumes the argument to prevent aliasing. The \u003ccode\u003eupdate\u003c/code\u003e function also consumes the argument to prevent aliasing. It uses the \u003ca href=\"http://tutorial.ponylang.org/capabilities/consume-and-destructive-read.html\"\u003edestructive read\u003c/a\u003e syntax to assign the argument \u003ccode\u003ex\u003c/code\u003e to the field \u003ccode\u003ea\u003c/code\u003e and assign the old value of \u003ccode\u003ea\u003c/code\u003e to \u003ccode\u003eb\u003c/code\u003e to avoid aliasing. Unfortunately this example fails to compile:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eError:\nf3/main.pony:19:14: argument not a subtype of parameter\n    Foo.doit(consume b)\n             ^\n    Info:\n    f3/main.pony:12:12: parameter type: String iso\n      fun doit(s: String iso) =\u0026gt;\n               ^\n    f3/main.pony:19:14: argument type: String iso!\n        Foo.doit(consume b)\n                 ^\n    f3/main.pony:7:34: String iso! is not a subtype of String iso: iso! is not a subtype of iso\n      fun ref update(x: String iso): String iso =\u0026gt;\n                                     ^\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eFrom the discussion previously on \u003ccode\u003e!\u003c/code\u003e this error tells us that we are aliasing \u003ccode\u003eb\u003c/code\u003e. We can narrow it down by explicitly declaring the type of \u003ccode\u003eb\u003c/code\u003e:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003elet b: String iso = a.update(recover iso String end)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe error is due to \u003ccode\u003eupdate\u003c/code\u003e returning a \u003ccode\u003eString iso\u003c/code\u003e. We are consuming \u003ccode\u003eb\u003c/code\u003e and returning it as a \u003ccode\u003eString iso\u003c/code\u003e which then gets aliased when assigned to \u003ccode\u003eb\u003c/code\u003e in the main routine. Changing the return type to use hat resolves the issue. \u003ccode\u003econsume b\u003c/code\u003e returns the ephmeral type which is an object with no variable referencing it. It is safe to assign to a \u003ccode\u003eString iso\u003c/code\u003e so the change compiles:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eclass Box\n  var a: String iso\n\n  new create(x: String iso) =\u0026gt;\n    a = consume x\n\n  fun ref update(x: String iso): String iso^ =\u0026gt;\n    let b = a = consume x\n    consume b\n\nprimitive Foo\n  fun doit(s: String iso) =\u0026gt;\n    None\n\nactor Main\n  new create(env: Env) =\u0026gt;\n    let a = Box(recover iso String end)\n    let b = a.update(recover iso String end)\n    Foo.doit(consume b)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eAnother approach would be to return a \u003ccode\u003eString iso\u003c/code\u003e but change \u003ccode\u003edoit\u003c/code\u003e to be a \u003ccode\u003eString tag\u003c/code\u003e (the type that can alias a \u003ccode\u003eString iso\u003c/code\u003e). This compiles but because \u003ccode\u003edoit\u003c/code\u003e now takes \u003ccode\u003eString tag\u003c/code\u003e it is limited in what it can do with the string. The approach of using an ephemeral type allows obtaining the mutable object from the \u003ccode\u003eBox\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch3\u003eHat in parameters\u003c/h3\u003e\n\n\u003cp\u003eSometimes you'll see hat in parameter lists. The \u003ccode\u003eArray\u003c/code\u003e builtin has an \u003ccode\u003einit\u003c/code\u003e constructor that looks like:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003enew init(from: A^, len: USize)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThis initializes an array so that all elements are the \u003ccode\u003efrom\u003c/code\u003e value. To explore how this works, here's a smaller example that does something similar:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eclass Box[A]\n  var a: A\n  var b: A\n\n  new create(x: A^) =\u0026gt;\n    a = x\n    b = x\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eWithout the hat in \u003ccode\u003eA^\u003c/code\u003e there is an error due to aliasing. We can't assign \u003ccode\u003ex\u003c/code\u003e to both \u003ccode\u003ea\u003c/code\u003e and \u003ccode\u003eb\u003c/code\u003e in case \u003ccode\u003eA\u003c/code\u003e is an \u003ccode\u003eiso\u003c/code\u003e. With the hat it compiles. The is because an epehemeral reference capability is a way of saying \"a reference capability that, when aliased, results in the base reference capability\". So a \u003ccode\u003eString iso^\u003c/code\u003e can be assigned to a \u003ccode\u003eString iso\u003c/code\u003e, a \u003ccode\u003eString ref^\u003c/code\u003e can be assigned to a \u003ccode\u003eString ref\u003c/code\u003e, etc. This means the generic class itself compiles but using it for a \u003ccode\u003eString iso\u003c/code\u003e will fail due to aliasing but it can be used for other reference capability types. Compare this to a plain \u003ccode\u003ex: A\u003c/code\u003e where the generic class itself won't compile since a \u003ccode\u003eString iso\u003c/code\u003e can't be assigned to another \u003ccode\u003eString iso\u003c/code\u003e due to aliasing.\u003c/p\u003e\n\n\u003cp\u003eCode demonstrating this is:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eactor Main\n  new create(env: Env) =\u0026gt;\n    let a = Box[String iso](recover iso String end)\n    let c = Box[String ref](recover ref String end)\n    let e = Box[String val](recover val String end)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch1\u003eArrow\u003c/h1\u003e\n\n\u003cp\u003eThe arrow syntax (or \u003ccode\u003e-\u0026gt;\u003c/code\u003e) is known as \u003ca href=\"http://tutorial.ponylang.org/capabilities/arrow-types.html\"\u003eviewpoint adapter types\u003c/a\u003e and is related to \u003ca href=\"http://tutorial.ponylang.org/capabilities/combining-capabilities.html\"\u003eviewpoint adaption\u003c/a\u003e.\u003c/p\u003e\n\n\u003ch3\u003eArrow in error messages\u003c/h3\u003e\n\n\u003cp\u003eViewpoint adaption defines what the reference capability of a field looks like to some caller based on the reference capability of the object the field is being read from. This is important to maintain the reference capability guarantees. A \u003ccode\u003eval\u003c/code\u003e object should not be able to access an \u003ccode\u003eiso\u003c/code\u003e field as \u003ccode\u003eiso\u003c/code\u003e or it breaks the constraints of \u003ccode\u003eval\u003c/code\u003e - it should be immutable but obtaining it as \u003ccode\u003eiso\u003c/code\u003e allows mutation of the field. There is a table in \u003ca href=\"http://tutorial.ponylang.org/capabilities/combining-capabilities.html\"\u003eviewpoint adaption\u003c/a\u003e that shows what the mapping is.\u003c/p\u003e\n\n\u003cp\u003eAn example of an error that can occur by ignoring viewpoint adaption is in the following code:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eclass Something\n  var a: String iso\n\n  new create() =\u0026gt;\n    a = recover iso String end\n\n  fun doit(s: String) =\u0026gt;\n    a.append(s) \n\nactor Main\n  new create(env: Env) =\u0026gt;\n    let a = Something\n    a.doit(\"hello\")\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe error here is calling \u003ccode\u003eappend\u003c/code\u003e on a the \u003ccode\u003ea\u003c/code\u003e field in the \u003ccode\u003edoit\u003c/code\u003e method. By default methods have a receiver reference capability of \u003ccode\u003ebox\u003c/code\u003e. Anything that happens inside the method cannot affect the state of the object. This is why you see methods that modify object fields start with \u003ccode\u003efun ref\u003c/code\u003e - it's to change the receiver reference capability to something mutable. Even though the field \u003ccode\u003ea\u003c/code\u003e is \u003ccode\u003eiso\u003c/code\u003e and therefore mutable because we are inside a \u003ccode\u003ebox\u003c/code\u003e method it appears as a non-mutable reference capability. The viewpoint adaption table shows that a \u003ccode\u003ebox\u003c/code\u003e origin with an \u003ccode\u003eiso\u003c/code\u003e field gives a \u003ccode\u003etag\u003c/code\u003e type. So \u003ccode\u003ea\u003c/code\u003e looks like a \u003ccode\u003eString tag\u003c/code\u003e within the method. The compiler gives:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eError:\nv/main.pony:8:13: receiver type is not a subtype of target type\n    a.append(s) \n            ^\n    Info:\n    v/main.pony:8:5: receiver type: this-\u0026gt;String iso!\n        a.append(s) \n        ^\n    ny/ponyc/packages/builtin/string.pony:622:3: target type: String ref\n      fun ref append(seq: ReadSeq[U8], offset: USize = 0, len: USize = -1)\n      ^\n    v/main.pony:2:10: String tag is not a subtype of String ref: tag is not a subtype of ref\n      var a: String iso\n             ^\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe 'receiver type' of \u003ccode\u003ethis-\u0026gt;String iso!\u003c/code\u003e is an example of arrow usage. It's saying that an object of type \u003ccode\u003eString iso!\u003c/code\u003e (an alias to a \u003ccode\u003eString iso\u003c/code\u003e) as seen by an origin of \u003ccode\u003ethis\u003c/code\u003e. The reference capability of \u003ccode\u003ethis\u003c/code\u003e in a method is that of the receiver reference capability on the function - in this case \u003ccode\u003ebox\u003c/code\u003e. So \u003ccode\u003ethis-\u0026gt;String iso!\u003c/code\u003e is \u003ccode\u003eString tag\u003c/code\u003e. That's why the last error description line refers to \u003ccode\u003eString tag\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThe solution here is to change the reference capability for the method to something that allows mutation:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003efun ref doit(s: String) =\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch3\u003eArrow in type declarations\u003c/h3\u003e\n\n\u003cp\u003eWhen writing generic code it's sometimes required to be explicit in what viewpoint adaption to use for generic types. Returning to the \u003ccode\u003eBox\u003c/code\u003e example used previously we'll make it generic and make it usable for any reference capability:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eclass Box[A]\n  var a: A\n\n  new create(x: A) =\u0026gt;\n    a = consume x\n\n  fun apply(): this-\u0026gt;A! =\u0026gt;\n    a\n\n  fun ref update(x: A): A^ =\u0026gt;\n    let b = a = consume x\n    consume b\n\n  fun clone(): Box[this-\u0026gt;A!] =\u0026gt;\n    Box[this-\u0026gt;A!](a)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eNotice the use of \u003ccode\u003ethis-\u0026gt;A!\u003c/code\u003e in the return type of \u003ccode\u003eapply\u003c/code\u003e. We want to return what is held in the \u003ccode\u003eBox\u003c/code\u003e. If it is a \u003ccode\u003eBox[String val] val\u003c/code\u003e then we can return a \u003ccode\u003eString val\u003c/code\u003e since it is immutable and the box is immutable. If it is a \u003ccode\u003eBox[String ref] val\u003c/code\u003e we still want to return a \u003ccode\u003eString val\u003c/code\u003e, not a \u003ccode\u003eString ref\u003c/code\u003e. The latter would allow modifying an immutable box. If it's a \u003ccode\u003eBox[String ref] ref\u003c/code\u003e then it's safe to return a \u003ccode\u003eString ref\u003c/code\u003e. This is what the arrow type handles for us. The \u003ccode\u003ethis\u003c/code\u003e refers to the reference capability of the object. The \u003ccode\u003eA!\u003c/code\u003e refers to the field type - note that it is being aliased here so we want a type that can hold an alias to an \u003ccode\u003eA\u003c/code\u003e. The viewpoint adaption gives the resulting reference capability of the type.\u003c/p\u003e\n\n\u003cp\u003eLooking up the table of \u003ca href=\"http://tutorial.ponylang.org/capabilities/combining-capabilities.html\"\u003eviewpoint adaption\u003c/a\u003e gives:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eBox[String val] val =\u0026gt; val-\u0026gt;val =\u0026gt; val =\u0026gt; String val\nBox[String ref] val =\u0026gt; val-\u0026gt;ref =\u0026gt; val =\u0026gt; String val\nBox[String ref] ref =\u0026gt; ref-\u0026gt;ref =\u0026gt; ref =\u0026gt; String ref\nBox[String iso] ref =\u0026gt; ref-\u0026gt;iso =\u0026gt; iso =\u0026gt; String iso\nBox[String ref] iso =\u0026gt; iso-\u0026gt;ref =\u0026gt; tag =\u0026gt; String tag\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThat last one is interesting in that the \u003ccode\u003eBox[String ref] iso\u003c/code\u003e says that only one reference of the \u003ccode\u003eBox\u003c/code\u003e can exist. If we allow a \u003ccode\u003eString ref\u003c/code\u003e to be obtained from it then it breaks this condition since both the original reference to the box can modify the string and so can the returned reference. This is why the viewpoint adaption gives a \u003ccode\u003eString tag\u003c/code\u003e. A \u003ccode\u003etag\u003c/code\u003e only allows identity operations so it's safe to have this type of alias of an \u003ccode\u003eiso\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eNote that the table above gives the mapping for \u003ccode\u003ethis-\u0026gt;A\u003c/code\u003e. Because it's a \u003ccode\u003ethis-\u0026gt;A!\u003c/code\u003e it has to be a type that can hold an alias to the type of the table. So we have another mapping:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eString val! =\u0026gt; String val\nString ref! =\u0026gt; String ref\nString iso! =\u0026gt; String tag\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eIn this way a \u003ccode\u003eBox[String iso] ref\u003c/code\u003e will give out a \u003ccode\u003eString tag\u003c/code\u003e - the only safe way of aliasing the original string in the box.\u003c/p\u003e\n\n\u003cp\u003eThe other use of an arrow type in this example is in the \u003ccode\u003eclone\u003c/code\u003e function. This must do a shallow copy of the object. It returns a new \u003ccode\u003eBox\u003c/code\u003e holding a reference to the same value. Because we need to alias the value the same constraints as described for the \u003ccode\u003eapply\u003c/code\u003e method exist. We want to return a \u003ccode\u003eBox[this-\u0026gt;A!]\u003c/code\u003e to ensure the value object for that box instance is a safe alias to the original. For a \u003ccode\u003eBox[String iso] ref\u003c/code\u003e this returns a \u003ccode\u003eBox[String tag]\u003c/code\u003e for example.\u003c/p\u003e\n\n\u003cp\u003eThe following code can be used with the \u003ccode\u003eBox\u003c/code\u003e class above to test it:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eprimitive Foo\n  fun doit(s: String tag) =\u0026gt;\n    None\n\nactor Main\n  new create(env: Env) =\u0026gt;\n    let a = Box[String iso](recover iso String end)\n    let b = a.clone()\n    Foo.doit(b())\n\n    let c = Box[String ref](recover ref String end)\n    let d = c.clone()\n    Foo.doit(d())\n\n    let e = Box[String val](recover val String end)\n    let f = e.clone()\n    Foo.doit(f())\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch3\u003eA-\u003eB arrows\u003c/h3\u003e\n\n\u003cp\u003eArrow types don't need to always use \u003ccode\u003ethis\u003c/code\u003e on the receiver side. They can use an explicit reference capability like \u003ccode\u003ebox-\u0026gt;A\u003c/code\u003e or they can use another parameterized type. Examples of this are in some of the library code:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eclass ArrayValues[A, B: Array[A] #read] is Iterator[B-\u0026gt;A]\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eAn \u003ccode\u003eArrayValues\u003c/code\u003e is returned by the \u003ccode\u003evalues\u003c/code\u003e method on \u003ccode\u003eArray\u003c/code\u003e. It's an iterator over the objects in the array. The \u003ccode\u003eB-\u0026gt;A\u003c/code\u003e syntax means that the type of the generic argument to \u003ccode\u003eIterator\u003c/code\u003e is of type \"\u003ccode\u003eA\u003c/code\u003e as seen by \u003ccode\u003eB\u003c/code\u003e\" using viewpoint adaption. It's not an iterator over \u003ccode\u003eA\u003c/code\u003e, it's an iterator over \"A as seen by B\". This allows iteration over arrays whether they are \u003ccode\u003eval\u003c/code\u003e or \u003ccode\u003eref\u003c/code\u003e and produces a compatible type for the \u003ccode\u003eIterator\u003c/code\u003e that works with both.\u003c/p\u003e\n\n\u003ch1\u003eConclusion\u003c/h1\u003e\n\n\u003cp\u003eMost of the functionality described here is some of the more esotoric Pony functionality. It is mainly hit when using generics. The best current reference for generics is a video by Sylvan Clebsch for the virtual Pony users group - \u003ca href=\"https://www.youtube.com/watch?v=Vq1vRfv-A6g\"\u003eWriting Generic Code\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003eA good way to learn is to try some of the examples in this post and play around with them. Try aliasing, using different types, different reference capabilities and see what happens. The Pony library code, \u003ca href=\"https://github.com/ponylang/ponyc/blob/master/packages/builtin/array.pony\"\u003eArray.pony for example\u003c/a\u003e, is a useful reference.\u003c/p\u003e\n\n      \u003cdiv\u003eTags: \n        \n          \u003ca href=\"./tags/pony/index.html\"\u003epony\u003c/a\u003e\u0026nbsp;\n        \n      \u003c/div\u003e\n      \u003c/div\u003e\n      \u003chr\u003e\n    \u003c/div\u003e\n  \n\u003cdiv\u003e\n  \n    \u003ca class=\"pagination\" href=\"./page2/index.html\" title=\"older\"\u003e\u0026larr; Older\u003c/a\u003e\n  \n  \n\u003c/div\u003e\n\n      \u003chr\u003e\n      \u003cdiv class=\"span-20\"\u003e\n        \u003cp style=\"text-align:center\"\u003eThis site is accessable over tor as hidden service \u003ca href=\"http://mh7mkfvezts5j6yu.onion/\"\u003emh7mkfvezts5j6yu.onion\u003c/a\u003e, or\n        Freenet using key:\u003cbr\u003e\u003csmall\u003e\u003cstrong\u003eUSK@1ORdIvjL2H1bZblJcP8hu2LjjKtVB-rVzp8mLty~5N4,8hL85otZBbq0geDsSKkBK4sKESL2SrNVecFZz9NxGVQ,AQACAAE/bluishcoder/-30/\u003c/strong\u003e\u003c/small\u003e\u003c/p\u003e\n        \u003chr\u003e\n        \u003cul class=\"links-lhs\"\u003e\n          \u003cli\u003e\u003ca href=\"http://bitmessage.org/\"\u003eBitMessage\u003c/a\u003e: \u003cstrong\u003eBM-NBJUkKSWQdGMnVtL8YWvDjVNRQ7LYgEW\u003c/strong\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"http://freesocial.draketo.de/sone_en.html\"\u003eSone\u003c/a\u003e: \u003cstrong\u003eI~1WtO9K-RzSO7Hxr8oqLFVrqjtwMrdmPSqhqsxN5Z4\u003c/strong\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"http://freesocial.draketo.de/freemail_en.html\"\u003eFreemail\u003c/a\u003e: \u003cstrong\u003edoublec@epwvnnhpjl6rzur3why27srkfrkwxkr3oazlozr5fkq2vtcn4wpa.freemail\u003c/strong\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n        \u003cul class=\"links-rhs\"\u003e\n          \u003cli\u003e\u003ca href=\"https://keybase.io/doublec\"\u003eKeybase\u003c/a\u003e\u003c/li\u003e\n\u003c!--          \u003cli\u003e\u003ca href=\"https://nameid.org/?name=doublec\"\u003eName ID\u003c/a\u003e\u003c/li\u003e --\u003e\n        \u003c/ul\u003e\n      \u003c/div\u003e\n    \u003c/div\u003e\n    \u003cdiv class=\"span-4 last\"\u003e\n      \u003cdiv class=\"small-heading\"\u003eTags\u003c/div\u003e\n      \u003cdiv class=\"span-4 tags\"\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/acme/index.html\"\u003eacme\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e1\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/ajax/index.html\"\u003eajax\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e7\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/alice/index.html\"\u003ealice\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e1\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/aliceml/index.html\"\u003ealiceml\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e1\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/ats/index.html\"\u003eats\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e25\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/audio/index.html\"\u003eaudio\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e2\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/b2g/index.html\"\u003eb2g\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e4\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/backbase/index.html\"\u003ebackbase\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e1\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/bitcoin/index.html\"\u003ebitcoin\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e3\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/bjj/index.html\"\u003ebjj\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e1\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/blackdog/index.html\"\u003eblackdog\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e3\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/commonlisp/index.html\"\u003ecommonlisp\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e10\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/concurrency/index.html\"\u003econcurrency\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e4\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/continuations/index.html\"\u003econtinuations\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e10\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/cyclone/index.html\"\u003ecyclone\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e1\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/dojo/index.html\"\u003edojo\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e1\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/eee/index.html\"\u003eeee\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e1\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/erlang/index.html\"\u003eerlang\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e20\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/facebook/index.html\"\u003efacebook\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e2\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/factor/index.html\"\u003efactor\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e60\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/firefox/index.html\"\u003efirefox\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e6\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/flash/index.html\"\u003eflash\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e1\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/forth/index.html\"\u003eforth\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e2\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/freenet/index.html\"\u003efreenet\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e2\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/fxos/index.html\"\u003efxos\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e4\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/git/index.html\"\u003egit\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e6\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/gstreamer/index.html\"\u003egstreamer\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e5\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/happs/index.html\"\u003ehapps\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e2\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/haskell/index.html\"\u003ehaskell\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e14\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/hyperscope/index.html\"\u003ehyperscope\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e1\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/inferno/index.html\"\u003einferno\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e7\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/io/index.html\"\u003eio\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e2\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/javascript/index.html\"\u003ejavascript\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e36\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/links/index.html\"\u003elinks\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e1\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/martialarts/index.html\"\u003emartialarts\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e4\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/minix/index.html\"\u003eminix\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e1\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/misc/index.html\"\u003emisc\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e15\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/mobile/index.html\"\u003emobile\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e2\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/mozartoz/index.html\"\u003emozartoz\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e1\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/mozilla/index.html\"\u003emozilla\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e99\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/namecoin/index.html\"\u003enamecoin\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e1\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/nanojit/index.html\"\u003enanojit\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e1\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/nixos/index.html\"\u003enixos\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e3\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/ocaml/index.html\"\u003eocaml\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e1\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/occam/index.html\"\u003eoccam\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e1\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/ogg/index.html\"\u003eogg\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e9\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/openid/index.html\"\u003eopenid\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e1\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/picolisp/index.html\"\u003epicolisp\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e1\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/pitcairn/index.html\"\u003epitcairn\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e5\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/poker/index.html\"\u003epoker\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e1\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/pony/index.html\"\u003epony\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e7\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/programming/index.html\"\u003eprogramming\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e1\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/pure/index.html\"\u003epure\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e3\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/rust/index.html\"\u003erust\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e5\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/scala/index.html\"\u003escala\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e1\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/scheme/index.html\"\u003escheme\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e4\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/seaside/index.html\"\u003eseaside\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e6\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/self/index.html\"\u003eself\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e10\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/servo/index.html\"\u003eservo\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e1\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/smalltalk/index.html\"\u003esmalltalk\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e1\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/tamarin/index.html\"\u003etamarin\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e2\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/theora/index.html\"\u003etheora\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e5\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/tinyvid/index.html\"\u003etinyvid\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e7\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/ukulele/index.html\"\u003eukulele\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e4\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/urweb/index.html\"\u003eurweb\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e2\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/video/index.html\"\u003evideo\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e24\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/vodka/index.html\"\u003evodka\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e1\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/vorbis/index.html\"\u003evorbis\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e3\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/waspvm/index.html\"\u003ewaspvm\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e7\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/webm/index.html\"\u003ewebm\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e1\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/yaws/index.html\"\u003eyaws\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e1\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/zeronet/index.html\"\u003ezeronet\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e1\u003c/div\u003e\n         \n         \u003cdiv class=\"span-3\"\u003e\u003ca href=\"./tags/zimbra/index.html\"\u003ezimbra\u003c/a\u003e\u003c/div\u003e\n         \u003cdiv class=\"span-1 last\"\u003e2\u003c/div\u003e\n         \n      \u003c/div\u003e\n      \u003chr\u003e\n      \u003cdiv class=\"small-heading\"\u003eArchives\u003c/div\u003e\n      \u003cul class=\"archive\"\u003e\n        \u003cli\u003e\u003ca href=\"./2016/index.html\"\u003e2016\u003c/a\u003e\u003c/li\u003e\n        \u003cli\u003e\u003ca href=\"./2015/index.html\"\u003e2015\u003c/a\u003e\u003c/li\u003e\n        \u003cli\u003e\u003ca href=\"./2014/index.html\"\u003e2014\u003c/a\u003e\u003c/li\u003e\n        \u003cli\u003e\u003ca href=\"./2013/index.html\"\u003e2013\u003c/a\u003e\u003c/li\u003e\n        \u003cli\u003e\u003ca href=\"./2012/index.html\"\u003e2012\u003c/a\u003e\u003c/li\u003e\n        \u003cli\u003e\u003ca href=\"./2011/index.html\"\u003e2011\u003c/a\u003e\u003c/li\u003e\n        \u003cli\u003e\u003ca href=\"./2010/index.html\"\u003e2010\u003c/a\u003e\u003c/li\u003e\n        \u003cli\u003e\u003ca href=\"./2009/index.html\"\u003e2009\u003c/a\u003e\u003c/li\u003e\n        \u003cli\u003e\u003ca href=\"./2008/index.html\"\u003e2008\u003c/a\u003e\u003c/li\u003e\n        \u003cli\u003e\u003ca href=\"./2007/index.html\"\u003e2007\u003c/a\u003e\u003c/li\u003e\n        \u003cli\u003e\u003ca href=\"./2006/index.html\"\u003e2006\u003c/a\u003e\u003c/li\u003e\n        \u003cli\u003e\u003ca href=\"./2005/index.html\"\u003e2005\u003c/a\u003e\u003c/li\u003e\n      \u003c/ul\u003e\n      \u003cdiv class=\"small-heading\"\u003eLinks\u003c/div\u003e\n      \u003cul class=\"archive\"\u003e\n        \u003cli\u003e\u003ca href=\"./articles/index.html\"\u003eArticles\u003c/a\u003e\u003c/li\u003e\n        \u003cli\u003e\u003ca href=\"./index.html\"\u003eWeblog\u003c/a\u003e\u003c/li\u003e\n      \u003c/ul\u003e\n      \u003ca href=\"./index.html\"\u003e\u003cimg width=180 height=36 src=\"./activelink.png\"/\u003e\u003c/a\u003e\n    \u003c/div\u003e \n    \u003chr\u003e\n    \u003cdiv class=\"span-24 blog-footer\"\u003eCopyright (c) 2010, Chris Double. All Rights Reserved.\u003c/div\u003e\n  \u003c/div\u003e\n\u003c!-- Start of StatCounter Code for Default Guide --\u003e\n\u003cscript type=\"text/javascript\"\u003e\nvar sc_project=1030053; \nvar sc_invisible=1; \nvar sc_security=\"4afd9f42\"; \nvar scJsHost = ((\"https:\" == document.location.protocol) ?\n\"https://secure.\" : \"http://www.\");\ndocument.write(\"\u003csc\"+\"ript type='text/javascript' src='\" +\nscJsHost+\n\"statcounter.com/counter/counter.js'\u003e\u003c/\"+\"script\u003e\");\n\u003c/script\u003e\n\u003c!-- End of StatCounter Code for Default Guide --\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n","pageTitle":"Bluish Coder","responseHeaders":{"CONNECTION":"keep-alive","CONTENT-TYPE":"text/html","DATE":"Thu, 21 Jul 2016 16:48:31 GMT","LAST-MODIFIED":"Mon, 18 Jul 2016 12:23:29 GMT","SERVER":"nginx/1.6.2 (Ubuntu)"},"bitcoinAddresses":null,"sshKey":"","ftpFingerprint":"","ftpBanner":"","smtpFingerprint":"","smtpBanner":""}
